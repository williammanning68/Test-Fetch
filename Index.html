<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tasmania Election Results Dashboard</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    <style>
        :root {
            --federal-gold: #C5A572;
            --federal-navy: #4A5A6A;
            --federal-dark: #475560;
            --federal-light: #ECF0F1;
            --federal-accent: #D4AF37;
            --liberal-color: #8EAADB;
            --labor-color: #EB8989;
            --greens-color: #A8D08D;
            --independent-color: #7030A0;
            --jln-color: #FFD966;
            --nationals-color: #008000;
            --shooters-color: #805200;
            --default-color: #B8B8B8;
            --informal-color: #666666;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--federal-light);
            color: var(--federal-dark);
            line-height: 1.6;
        }
        
        .header {
            background: linear-gradient(135deg, var(--federal-dark) 0%, var(--federal-dark) 100%);
            color: white;
            padding: 1.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            position: relative;
        }
        
.header h1 {
    font-size: 2rem;
    margin-bottom: 0.5rem;
    color: white; /* plain white text */
    background: none; /* remove background gradient */
    -webkit-background-clip: unset;
    -webkit-text-fill-color: unset;
    background-clip: unset;
}
        
       .logo {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    right: 1.5rem;   /* unchanged */
    height: 60px;   /* unchanged */
    display: flex;
    align-items: center;
}
        .logo svg {
            height: 40px;
            width: auto;
        }
        
        .controls {
            background: white;
            padding: 1.5rem;
            margin: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .control-group label {
    display: block !important;
    margin-bottom: 0.5rem !important;
}
        .control-group.primary {
            order: -1;
            padding-right: 1rem;
            border-right: 2px solid var(--federal-light);
        }
        
        .control-group label {
            font-weight: 600;
            color: var(--federal-navy);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        select, button {
            padding: 0.6rem 1rem;
            border: 2px solid var(--federal-gold);
            border-radius: 6px;
            background: white;
            color: var(--federal-dark);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:hover, button:hover {
            border-color: var(--federal-accent);
            box-shadow: 0 2px 8px rgba(197, 165, 114, 0.3);
        }
        
        button {
            background: var(--federal-gold);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        button:hover {
            background: var(--federal-accent);
        }
        
        button.active {
            background: var(--federal-navy);
            border-color: var(--federal-navy);
        }
        
        .content {
            margin: 1.5rem;
        }
        
        .panel-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .panel {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .panel.full-width {
            grid-column: 1 / -1;
        }
        
        .panel h2 {
            color: var(--federal-navy);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--federal-gold);
        }
        
        .panel h3 {
            color: var(--federal-navy);
            margin-bottom: 0.75rem;
            font-size: 1.1rem;
        }
        
        .chart-container {
            height: 400px;
            margin-bottom: 2rem;
            position: relative;
        }
        
        .chart-container.small {
            height: 250px;
            margin-bottom: 1rem;
        }
        
        .table-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--federal-light);
            border-radius: 8px;
        }
        
        .table-container.small {
            max-height: 250px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th {
            background: var(--federal-navy);
            color: white;
            padding: 0.8rem;
            text-align: left;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        td {
            padding: 0.6rem 0.8rem;
            border-bottom: 1px solid var(--federal-light);
        }
        
        tr:hover {
            background: rgba(197, 165, 114, 0.1);
        }
        
        .loading {
            text-align: center;
            padding: 3rem;
            color: var(--federal-navy);
        }
        
        canvas {
            max-height: 400px !important;
        }
        
        .multi-select-container {
            position: relative;
            min-width: 200px;
        }
        
        .multi-select-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid var(--federal-gold);
            border-radius: 6px;
            max-height: 250px;
            overflow-y: auto;
            display: none;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .multi-select-dropdown.show {
            display: block;
        }
        
        .multi-select-option {
            padding: 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .multi-select-option:hover {
            background: var(--federal-light);
        }
        
        .multi-select-option input[type="checkbox"] {
            accent-color: var(--federal-gold);
        }
        
        .multi-select-display {
            padding: 0.6rem 1rem;
            border: 2px solid var(--federal-gold);
            border-radius: 6px;
            background: white;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .booth-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .stat-card {
            background: var(--federal-light);
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid var(--federal-gold);
        }
        
        .stat-card h3 {
            color: var(--federal-navy);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--federal-dark);
        }
        
        .stat-label {
            font-size: 0.85rem;
            color: #666;
            margin-top: 0.25rem;
        }
        
        .party-badge {
            display: inline-block;
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 600;
            color: white;
            margin-right: 0.25rem;
        }
        
        .booth-filters {
            background: var(--federal-light);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        #boothMap {
            height: 500px;
            width: 100%;
            border-radius: 8px;
            border: 2px solid var(--federal-light);
        }
        
        .map-legend {
            background: white;
            padding: 0.75rem;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 0.85rem;
        }
        
        .map-legend h4 {
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: var(--federal-navy);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .booth-popup {
            min-width: 200px;
        }
        
        .booth-popup h3 {
            margin: 0 0 0.5rem 0;
            color: var(--federal-navy);
            font-size: 1.1rem;
        }
        
        .booth-popup p {
            margin: 0.25rem 0;
            font-size: 0.9rem;
        }
        
        .booth-popup .winner {
            font-weight: bold;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            display: inline-block;
            margin-top: 0.5rem;
            color: white;
        }
        
        @media (max-width: 1024px) {
            .panel-grid {
                grid-template-columns: 1fr;
            }
        }
    
/* Ensure dropdown stays above the map */
.multi-select-dropdown { z-index: 2000; }
/* Tooltip styles */
.info-icon {
    display: inline-block;
    width: 16px;
    height: 16px;
    margin-left: 8px;
    background: var(--federal-gold);
    color: white;
    border-radius: 50%;
    text-align: center;
    line-height: 16px;
    font-size: 11px;
    font-weight: bold;
    cursor: help;
    position: relative;
    vertical-align: middle;
}

.info-icon:hover::after {
    content: attr(data-tooltip);
    position: absolute;
    bottom: 125%;
    left: 50%;
    transform: translateX(-50%);
    background: #333;
    color: white;
    padding: 8px 12px;
    border-radius: 6px;
    white-space: normal;
    width: 250px;
    font-size: 12px;
    font-weight: normal;
    z-index: 1000;
    line-height: 1.4;
    box-shadow: 0 2px 8px rgba(0,0,0,0.2);
}

.info-icon:hover::before {
    content: "";
    position: absolute;
    bottom: 115%;
    left: 50%;
    transform: translateX(-50%);
    border: 6px solid transparent;
    border-top-color: #333;
    z-index: 1000;
}
/* LC-specific stat cards */
.lc-summary-tiles {
    display: grid;
    grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
    gap: 1rem;
    margin-bottom: 2rem;
}

.lc-stat-tile {
    background: linear-gradient(135deg, var(--federal-light) 0%, white 100%);
    padding: 1.2rem;
    border-radius: 10px;
    border-left: 4px solid var(--federal-gold);
    box-shadow: 0 2px 8px rgba(0,0,0,0.05);
}

.lc-stat-tile h4 {
    color: var(--federal-navy);
    font-size: 0.85rem;
    margin-bottom: 0.5rem;
    text-transform: uppercase;
    letter-spacing: 0.5px;
}

.lc-stat-tile .value {
    font-size: 1.5rem;
    font-weight: bold;
    color: var(--federal-dark);
}

.lc-stat-tile .sub-value {
    font-size: 0.9rem;
    color: #666;
    margin-top: 0.25rem;
}
/* Searchable dropdown styles */
.searchable-dropdown {
    position: relative;
    min-width: 200px;
}

.searchable-dropdown-toggle {
    padding: 0.6rem 1rem;
    border: 2px solid var(--federal-gold);
    border-radius: 6px;
    background: white;
    cursor: pointer;
    display: flex;
    justify-content: space-between;
    align-items: center;
    font-size: 1rem;
    color: var(--federal-dark);
    transition: all 0.3s ease;
}

.searchable-dropdown-toggle:hover {
    border-color: var(--federal-accent);
    box-shadow: 0 2px 8px rgba(197, 165, 114, 0.3);
}

.searchable-dropdown-menu {
    position: absolute;
    top: 100%;
    left: 0;
    right: 0;
    background: white;
    border: 2px solid var(--federal-gold);
    border-radius: 6px;
    max-height: 300px;
    overflow-y: auto;
    display: none;
    z-index: 2000;
    box-shadow: 0 4px 12px rgba(0,0,0,0.15);
    margin-top: 2px;
}

.searchable-dropdown-menu.show {
    display: block;
}

.searchable-dropdown-search {
    padding: 0.5rem;
    border-bottom: 1px solid var(--federal-light);
    position: sticky;
    top: 0;
    background: white;
    z-index: 1;
}

.searchable-dropdown-search input {
    width: 100%;
    padding: 0.4rem 0.6rem;
    border: 1px solid var(--federal-light);
    border-radius: 4px;
    font-size: 0.95rem;
    outline: none;
}

.searchable-dropdown-search input:focus {
    border-color: var(--federal-gold);
}

.searchable-dropdown-options {
    max-height: 250px;
    overflow-y: auto;
}

.searchable-dropdown-option {
    padding: 0.6rem 1rem;
    cursor: pointer;
    transition: background 0.2s;
}

.searchable-dropdown-option:hover {
    background: var(--federal-light);
}

.searchable-dropdown-option.selected {
    background: rgba(197, 165, 114, 0.1);
    font-weight: 600;
}

.searchable-dropdown-option.hidden {
    display: none;
}

.searchable-dropdown-no-results {
    padding: 1rem;
    text-align: center;
    color: #666;
    font-style: italic;
}
</style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
</head>
<body>
    <div class="header">
        <h1>Tasmanian Election Results Dashboard</h1>
        <p>Comprehensive election data analysis for State and Legislative Council elections</p>
        <p style="font-size: 0.85rem; opacity: 0.8; margin-top: 0.5rem;"></p>
<div class="logo">
          <img
  src="https://cdn.jsdelivr.net/gh/williammanning68/Test-Fetch@237dcd83d094fc337de46388e743f68cf4023087/Federal%20Group%20Logo.png"
  alt="Federal Group logo"
  width="455" height="118" />
        </div>
    </div>


    <div class="controls">
        <div class="control-group primary">
            <label>View Scope</label>
            <select id="scopeSelect" onchange="updateDashboard()">
                <option value="state">Statewide</option>
                <option value="electorate">Electorate</option>
                <option value="booth">Booth</option>
                                <option value="boothAnalysis">Booth Analysis</option>
<option value="candidate">Individual Candidate</option>
                <option value="historical">Historical Trends</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Election Type</label>
            <div style="display: flex; gap: 0.5rem;">
                <button id="btnState" class="active" onclick="switchElectionType('state')">State Election</button>
                <button id="btnLC" onclick="switchElectionType('lc')">Legislative Council</button>
            </div>
        </div>
        
        <div class="control-group" id="yearGroup">
            <label>Select Year</label>
            <select id="yearSelect" onchange="updateDashboard()">
                <option value="">Loading...</option>
            </select>
        </div>
        
        <div class="control-group" id="electorateGroup" style="display: none;">
            <label id="electorateLabel">Select Electorate</label>
            <select id="electorateSelect" onchange="updateDashboard()">
                <option value="">All Electorates</option>
            </select>
        </div>
        
        <div class="control-group" id="boothGroup" style="display: none;">
    <label>Select Booth</label>
    <div class="searchable-dropdown" id="boothDropdown">
        <div class="searchable-dropdown-toggle" onclick="toggleSearchableDropdown('booth')">
            <span id="boothSelectedText">All Booths</span>
            <span>▼</span>
        </div>
        <div class="searchable-dropdown-menu" id="boothDropdownMenu">
            <div class="searchable-dropdown-search">
                <input type="text" placeholder="Type to search..." onkeyup="filterDropdownOptions('booth', this.value)">
            </div>
            <div class="searchable-dropdown-options" id="boothOptions">
                <!-- Options will be populated dynamically -->
            </div>
        </div>
    </div>
    <input type="hidden" id="boothSelect" value="">
</div>
        
        <div class="control-group" id="candidateGroup" style="display: none;">
    <label>Select Candidate</label>
    <div class="searchable-dropdown" id="candidateDropdown">
        <div class="searchable-dropdown-toggle" onclick="toggleSearchableDropdown('candidate')">
            <span id="candidateSelectedText">Select a candidate</span>
            <span>▼</span>
        </div>
        <div class="searchable-dropdown-menu" id="candidateDropdownMenu">
            <div class="searchable-dropdown-search">
                <input type="text" placeholder="Type to search..." onkeyup="filterDropdownOptions('candidate', this.value)">
            </div>
            <div class="searchable-dropdown-options" id="candidateOptions">
                <!-- Options will be populated dynamically -->
            </div>
        </div>
    </div>
    <input type="hidden" id="candidateSelect" value="">
</div>
    </div>

    <div class="content" id="mainContent"></div>

    <script>
        // =====================================================
        // POLLING PLACE COORDINATES - Will be fetched from JSON
        // =====================================================
        let POLLING_PLACES = {};
        
        // URL for polling places data
        const POLLING_PLACES_URL = 'https://raw.githubusercontent.com/williammanning68/Test-Fetch/main/Polling%20Locations%20-%20Year%20and%20Election%20Type.json';
        
        // Function to fetch polling places data
        
        // Normalize booth names to improve lookup hit rate
        function keyForBooth(name){
            return (name || "").replace(/\s*\(.*?\)\s*$/,'').trim();
        }
    async function fetchPollingPlaces() {
            try {
                console.log('Fetching polling places data...');
                const response = await fetch(POLLING_PLACES_URL, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const raw = await response.json();
                const data = raw.POLLING_PLACES || raw;
                console.log('Polling places data fetched successfully');
                
                // Store the polling places data (unwrapped)
                POLLING_PLACES = data;
                console.log('POLLING_PLACES loaded:', Object.keys(POLLING_PLACES).length, 'locations');
                
                return true;
            } catch (error) {
                console.error('Error fetching polling places:', error);
                // Use empty object as fallback
                POLLING_PLACES = {};
                return false;
            }
        }
        
        // =====================================================
        // ELECTION DATA
        // =====================================================
        
        // Data will be fetched from GitHub
        let ELECTION_DATA = {
            state: {},
            lc: {}
        };
        
        let SEAT_RESULTS = {
            state: {},
            lc: {}
        };
        
        // GitHub data URL - Update this to your raw JSON URL
        const DATA_URL = 'https://raw.githubusercontent.com/williammanning68/Test-Fetch/main/converted_election_data_full.json';
        
        // Function to fetch data from GitHub
        async function fetchElectionData() {
            try {
                console.log('Fetching data from GitHub...');
                console.log('URL:', DATA_URL);
                
                // First fetch polling places
                const pollingPlacesLoaded = await fetchPollingPlaces();
                if (!pollingPlacesLoaded) {
                    console.warn('Polling places data could not be loaded, map features may be limited');
                }
                
                const response = await fetch(DATA_URL, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Data fetched successfully:', data);
                
                // Update the global data objects
                if (data.ELECTION_DATA) {
                    ELECTION_DATA = data.ELECTION_DATA;
                    console.log('ELECTION_DATA loaded:', ELECTION_DATA);
                }
                if (data.SEAT_RESULTS) {
                    SEAT_RESULTS = data.SEAT_RESULTS;
                    console.log('SEAT_RESULTS loaded:', SEAT_RESULTS);
                }
                
                // If data structure is different (direct state/lc keys)
                if (!data.ELECTION_DATA && (data.state || data.lc)) {
                    ELECTION_DATA.state = data.state || {};
                    ELECTION_DATA.lc = data.lc || {};
                    console.log('Alternative data structure detected and loaded');
                }
                
                // Initialize the dashboard with default selections
                updateYearDropdown();
                updateElectorateDropdown();
                updateBoothDropdown();
                updateCandidateDropdown();
                updateDashboard();
                
                // Hide loading message
                const loadingMsg = document.getElementById('loadingMessage');
                if (loadingMsg) {
                    loadingMsg.style.display = 'none';
                }
                
            } catch (error) {
                console.error('Error fetching data:', error);
                
                // Show error message with more details
                const content = document.getElementById('mainContent');
                content.innerHTML = `
                    <div class="panel full-width">
                        <h2>Error Loading Data</h2>
                        <p style="color: #d32f2f;">Failed to load election data from GitHub.</p>
                        <p>Error: ${error.message}</p>
                        <p style="margin-top: 1rem;">Please check:</p>
                        <ul style="margin-left: 2rem;">
                            <li>The GitHub repository is public</li>
                            <li>The JSON file exists at the specified URL</li>
                            <li>The JSON format is valid</li>
                            <li>Check browser console (F12) for more details</li>
                        </ul>
                        <p style="margin-top: 1rem;">URL attempted: <code style="background: #f5f5f5; padding: 0.25rem 0.5rem; border-radius: 4px;">${DATA_URL}</code></p>
                        <div style="margin-top: 2rem; display: flex; gap: 1rem;">
                            <button onclick="location.reload()">Retry Loading</button>
                            <button onclick="useFallbackData()" style="background: var(--federal-navy);">Use Demo Data</button>
                            <button onclick="showManualInput()" style="background: var(--federal-dark);">Paste JSON Manually</button>
                        </div>
                        <div id="manualInputArea" style="display: none; margin-top: 2rem;">
                            <h3>Paste JSON Data</h3>
                            <textarea id="jsonInput" style="width: 100%; height: 200px; font-family: monospace; padding: 0.5rem; border: 2px solid var(--federal-gold); border-radius: 6px;" placeholder="Paste your JSON data here..."></textarea>
                            <button onclick="loadManualData()" style="margin-top: 1rem;">Load Data</button>
                        </div>
                    </div>
                `;
                
                // Hide loading message
                const loadingMsg = document.getElementById('loadingMessage');
                if (loadingMsg) {
                    loadingMsg.style.display = 'none';
                }
            }
        }
        
        // =====================================================
        // CORE FUNCTIONS
        // =====================================================
        
        let currentElectionType = 'state';
        let currentData = [];
        let charts = {};
        let selectedParties = new Set(['ALL']);
        let boothMap = null;
        let mapMarkers = null;
        
        const NON_PHYSICAL_BOOTHS = [
            'postal', 'pre-poll', 'prepoll', 'mobile', 'provisional', 
            'out of division', 'telephone', 'pre poll', 'absent'
        ];
        
        function isPhysicalBooth(boothName) {
            const lowerName = boothName.toLowerCase();
            return !NON_PHYSICAL_BOOTHS.some(pattern => lowerName.includes(pattern));
        }
        
        
        // Normalize party codes and names to a single canonical set
        function normalizeParty(p) {
            const s = (p || '').toString().trim().toUpperCase();
            const map = {
                // Majors
                'LABOR': 'ALP', 'ALP': 'ALP',
                'LIBERAL': 'LIB', 'LIB': 'LIB',
                'GREENS': 'GRN', 'GRN': 'GRN',
                'INDEPENDENT': 'IND', 'IND': 'IND',
                'UG': 'IND', 'UNGROUPED': 'IND',
                // Minors / aliases
                'SFF': 'SFF', 'SSF': 'SFF', 'SHOOTERS & FISHERS': 'SFF',
                'NAT': 'NAT', 'NATIONALS': 'NAT',
                'JLN': 'JLN', 'JACQUI LAMBIE NETWORK': 'JLN',
                // Informal
                'INF': 'INF', 'INFORMAL': 'INF'
            };
            return map[s] || s;
        }

        function normalizeCandidateName(name) {
            return (name || "").toString().trim().toUpperCase();
        }
// Helper function to get previous LC election year for an electorate
function getPreviousLCElectionYear(electorate, currentYear) {
    if (currentElectionType !== 'lc') return null;
    
    const years = Object.keys(ELECTION_DATA.lc)
        .map(y => parseInt(y))
        .filter(y => y < currentYear)
        .sort((a, b) => b - a);
    
    for (const year of years) {
        const data = ELECTION_DATA.lc[year];
        if (data && data.some(d => d.d === electorate)) {
            return year;
        }
    }
    
    return null;
}
        
function getPartyColor(party) {
            const colorMap = {
                'LIB': '#8EAADB',
                'LIBERAL': '#8EAADB',
                'ALP': '#EB8989',
                'LABOR': '#EB8989',
                'GRN': '#A8D08D',
                'GREENS': '#A8D08D',
                'IND': '#7030A0',
                'INDEPENDENT': '#7030A0',
                'JLN': '#FFD966',
                'NAT': '#008000',
                'SFF': '#805200',
                'Shooters & Fishers': '#805200',
                'INF': '#666666'
            };
            return colorMap[normalizeParty(party)] || '#B8B8B8';
        }
        
        function getPartyName(code) {
            const partyNames = {
                'ALP': 'Labor',
                'LABOR': 'Labor',
                'LIB': 'Liberal',
                'LIBERAL': 'Liberal',
                'GRN': 'Greens',
                'GREENS': 'Greens',
                'IND': 'Independent',
                'INDEPENDENT': 'Independent',
                'JLN': 'JLN',
                'SFF': 'Shooters & Fishers',
                'Shooters & Fishers': 'Shooters & Fishers',
                'INF': 'Informal',
                'NAT': 'Nationals'
            };
            return partyNames[normalizeParty(code)] || code;
        }
        
        // Calculate booth winners from candidate data
        function calculateBoothWinners(year, electorate = '') {
            const data = currentElectionType === 'state' 
                ? ELECTION_DATA.state[year] 
                : ELECTION_DATA.lc[year];
            
            if (!data) return [];
            
            const boothResults = {};
            
            // Filter by electorate if specified
            const candidates = electorate 
                ? data.filter(d => d.d === electorate)
                : data;
            
            // Aggregate votes by booth
            candidates.forEach(candidate => {
                if (candidate.b && Array.isArray(candidate.b)) {
                    candidate.b.forEach(booth => {
                        if (isPhysicalBooth(booth.n)) {
                            if (!boothResults[booth.n]) {
                                boothResults[booth.n] = {
                                    name: booth.n,
                                    electorate: candidate.d,
                                    parties: {}
                                };
                            }
                            
                            const party = candidate.p;
                            if (!boothResults[booth.n].parties[party]) {
                                boothResults[booth.n].parties[party] = 0;
                            }
                            boothResults[booth.n].parties[party] += booth.v;
                        }
                    });
                }
            });
            
            // Determine winner for each booth
            const winners = [];
            Object.values(boothResults).forEach(booth => {
                let maxVotes = 0;
                let winningParty = '';
                
                Object.entries(booth.parties).forEach(([party, votes]) => {
                    if (votes > maxVotes && party !== 'INF') {
                        maxVotes = votes;
                        winningParty = party;
                    }
                });
                
                if (winningParty) {
                    winners.push({
                        name: booth.name,
                        electorate: booth.electorate,
                        party: winningParty,
                        votes: maxVotes,
                        margin: 0
                    });
                }
            });
            
            // Filter by selected parties
            return winners.filter(booth => {
                if (selectedParties.has('NONE')) return false;
                if (selectedParties.has('ALL')) return true;
                return selectedParties.has(booth.party);
            });
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Show loading message
            const content = document.getElementById('mainContent');
            content.innerHTML = `
                <div class="panel full-width" id="loadingMessage">
                    <h2>Loading Election Data...</h2>
                    <p style="text-align: center; padding: 2rem;">
                        <span style="font-size: 2rem;">⏳</span><br>
                        Fetching data from William's JSON Server<br>
                        <small style="opacity: 0.7;">This may take a few moments</small>
                    </p>
                    <div style="text-align: center; margin-top: 2rem;">
                        <button onclick="useFallbackData()" style="background: var(--federal-navy);">Use Demo Data Instead</button>
                    </div>
                </div>
            `;
            
            // Fetch data from GitHub
            fetchElectionData();
        });
        
        // Fallback function to use demo data
        function useFallbackData() {
            // Use minimal demo data
            ELECTION_DATA = {
                state: {
                    "2025": [
                        {"d": "Bass", "c": "Demo Candidate", "p": "ALP", "v": 1000, "b": [{"n": "Launceston", "v": 500}, {"n": "George Town", "v": 500}]}
                    ]
                },
                lc: {
                    "2024": [
                        {"d": "Elwick", "c": "Demo LC Candidate", "p": "IND", "v": 2000, "b": [{"n": "Glenorchy", "v": 1000}, {"n": "Moonah", "v": 1000}]}
                    ]
                }
            };
            
            SEAT_RESULTS = {
                state: {
                    "2025": [
                        {"electorate": "Bass", "party": "LABOR", "seats_won": 3, "total_seat_pct": "8.57%"},
                        {"electorate": "Bass", "party": "LIBERAL", "seats_won": 4, "total_seat_pct": "11.43%"}
                    ]
                },
                lc: {}
            };
            
            // Add demo polling places if not loaded
            if (Object.keys(POLLING_PLACES).length === 0) {
                POLLING_PLACES = {
                    "Launceston": {"lat": -41.43659, "lng": 147.13718, "electorate": "Bass"},
                    "George Town": {"lat": -41.10686, "lng": 146.82194, "electorate": "Bass"},
                    "Glenorchy": {"lat": -42.830908, "lng": 147.267619, "electorate": "Clark"},
                    "Moonah": {"lat": -42.84612742, "lng": 147.2997299, "electorate": "Clark"}
                };
            }
            
            console.log('Using fallback demo data');
            updateYearDropdown();
            updateDashboard();
            
            // Show notification
            const content = document.getElementById('mainContent');
            const notification = document.createElement('div');
            notification.style = 'background: #fff3cd; border: 1px solid #ffc107; padding: 1rem; margin-bottom: 1rem; border-radius: 8px;';
            notification.innerHTML = '<strong>Note:</strong> Using demo data. GitHub data could not be loaded.';
            content.insertBefore(notification, content.firstChild);
        }
        
        // Show manual input area
        function showManualInput() {
            const manualArea = document.getElementById('manualInputArea');
            if (manualArea) {
                manualArea.style.display = 'block';
            }
        }
        
        // Load manually pasted data
        function loadManualData() {
            try {
                const jsonInput = document.getElementById('jsonInput');
                if (!jsonInput || !jsonInput.value.trim()) {
                    alert('Please paste JSON data first');
                    return;
                }
                
                const data = JSON.parse(jsonInput.value);
                console.log('Manual data parsed:', data);
                
                // Update the global data objects
                if (data.ELECTION_DATA) {
                    ELECTION_DATA = data.ELECTION_DATA;
                } else if (data.state || data.lc) {
                    // Handle alternative structure
                    ELECTION_DATA.state = data.state || {};
                    ELECTION_DATA.lc = data.lc || {};
                }
                
                if (data.SEAT_RESULTS) {
                    SEAT_RESULTS = data.SEAT_RESULTS;
                } else if (data.seat_results) {
                    // Handle alternative naming
                    SEAT_RESULTS = data.seat_results;
                }
                
                console.log('Manual data loaded successfully');
                updateYearDropdown();
                updateDashboard();
                
            } catch (error) {
                alert('Error parsing JSON: ' + error.message);
                console.error('Manual data parse error:', error);
            }
        }
        
        function updateYearDropdown() {
            const yearSelect = document.getElementById('yearSelect');
            yearSelect.innerHTML = '';
            
            const years = currentElectionType === 'state' 
                ? Object.keys(ELECTION_DATA.state).filter(y => ELECTION_DATA.state[y].length > 0).sort((a, b) => b - a)
                : Object.keys(ELECTION_DATA.lc).filter(y => ELECTION_DATA.lc[y].length > 0).sort((a, b) => b - a);
            
            years.forEach(year => {
                yearSelect.innerHTML += `<option value="${year}">${year}</option>`;
            });
            
            yearSelect.value = years[0] || '';
        }
        
       function switchElectionType(type) {
    currentElectionType = type;
    document.getElementById('btnState').classList.toggle('active', type === 'state');
    document.getElementById('btnLC').classList.toggle('active', type === 'lc');

    // Reset dependent selections when changing election type
    document.getElementById('electorateSelect').value = '';
    document.getElementById('boothSelect').value = '';
    document.getElementById('candidateSelect').value = '';
    
    // Update scope label for LC
    const scopeSelect = document.getElementById('scopeSelect');
    const stateOption = scopeSelect.options[0];
    if (type === 'lc') {
        stateOption.text = 'Year Overview';
    } else {
        stateOption.text = 'Statewide';
    }

    updateYearDropdown();
    updateDashboard();
}

        function updateDashboard() {
    const scope = document.getElementById('scopeSelect').value;
    const year = document.getElementById('yearSelect').value;

    // Ensure dropdowns reflect the current election type and year
    if (scope === 'electorate' || scope === 'booth' || scope === 'candidate' || scope === 'boothAnalysis') {
        updateElectorateDropdown();
    }
    if (scope === 'booth') {
        updateBoothDropdown();
    }
    if (scope === 'candidate') {
        updateCandidateDropdown();
    }

    const electorate = document.getElementById('electorateSelect').value;
    const booth = document.getElementById('boothSelect').value;
    const candidate = document.getElementById('candidateSelect').value;

    // Clear existing charts and map
    Object.values(charts).forEach(chart => {
        if (chart) chart.destroy();
    });
    charts = {};
    
    if (boothMap) {
        boothMap.remove();
        boothMap = null;
        mapMarkers = null;
    }
    
    // Show/hide controls
    const isHistorical = scope === 'historical';
    document.getElementById('yearGroup').style.display = isHistorical ? 'none' : 'block';
    document.getElementById('electorateGroup').style.display = 
        (scope === 'electorate' || scope === 'booth' || scope === 'candidate' || scope === 'boothAnalysis') ? 'block' : 'none';
    document.getElementById('boothGroup').style.display = 
        scope === 'booth' ? 'block' : 'none';
    document.getElementById('candidateGroup').style.display = 
        scope === 'candidate' ? 'block' : 'none';
    
    document.getElementById('electorateLabel').textContent = 
        scope === 'electorate' ? 'Select Electorate' : 'Filter by Electorate';
    
    // Render appropriate view
    const content = document.getElementById('mainContent');
    
    switch(scope) {
        case 'historical':
            renderHistoricalView(content);
            break;
        case 'state':
            if (currentElectionType === 'lc') {
                renderLCYearOverview(content, year);
            } else {
                renderStatewideView(content, year);
            }
            break;
        case 'electorate':
            if (currentElectionType === 'lc') {
                renderLCElectorateView(content, year, electorate);
            } else {
                renderElectorateView(content, year, electorate);
            }
            break;
        case 'booth':
            renderBoothView(content, year, electorate, booth);
            break;
        case 'candidate':
            if (currentElectionType === 'lc') {
                renderLCCandidateView(content, year, candidate);
            } else {
                renderCandidateView(content, year, candidate);
            }
            break;
        case 'boothAnalysis':
            renderBoothAnalysisView(content, year, electorate);
            break;
    }
}
        
        function getCurrentData(year, scope, electorate, booth, candidate) {
            let data = [];
            
            const electionData = currentElectionType === 'state' 
                ? ELECTION_DATA.state 
                : ELECTION_DATA.lc;
            
            if (!year || year === '') return data;
            
            data = electionData[year] || [];
            
            if (electorate && scope !== 'state') {
                data = data.filter(d => d.d === electorate);
            }
            
            if (candidate && scope === 'candidate') {
                data = data.filter(d => d.c === candidate);
            }
            
            return data;
        }
        
        function updateElectorateDropdown() {
    const electorateSelect = document.getElementById('electorateSelect');
    const currentValue = electorateSelect.value;
    const year = document.getElementById('yearSelect').value;
    const data = currentElectionType === 'state' 
        ? ELECTION_DATA.state[year] 
        : ELECTION_DATA.lc[year];
    
    if (!data) {
        electorateSelect.innerHTML = '<option value="">No data available</option>';
        return;
    }
    
    const electorates = Array.from(new Set(data.map(d => d.d))).sort();
    
    // Update dropdown with appropriate default text for LC
    if (currentElectionType === 'lc') {
        electorateSelect.innerHTML = `<option value="">All Contested Electorates (${year})</option>`;
    } else {
        electorateSelect.innerHTML = '<option value="">All Electorates</option>';
    }
    
    electorates.forEach(elec => {
        electorateSelect.innerHTML += `<option value="${elec}">${elec}</option>`;
    });
    
    if (currentValue && electorates.includes(currentValue)) {
        electorateSelect.value = currentValue;
    }
}
        // Searchable dropdown functions
function toggleSearchableDropdown(type) {
    const menu = document.getElementById(`${type}DropdownMenu`);
    const isOpen = menu.classList.contains('show');
    
    // Close all other searchable dropdowns
    document.querySelectorAll('.searchable-dropdown-menu').forEach(m => {
        m.classList.remove('show');
    });
    
    if (!isOpen) {
        menu.classList.add('show');
        // Focus on search input
        const searchInput = menu.querySelector('input');
        if (searchInput) {
            setTimeout(() => searchInput.focus(), 50);
        }
    }
}

function selectDropdownOption(type, value, text) {
    // Update hidden select value
    document.getElementById(`${type}Select`).value = value;
    
    // Update display text
    document.getElementById(`${type}SelectedText`).textContent = text || value || (type === 'booth' ? 'All Booths' : 'Select a candidate');
    
    // Close dropdown
    document.getElementById(`${type}DropdownMenu`).classList.remove('show');
    
    // Clear search input
    const searchInput = document.querySelector(`#${type}DropdownMenu input`);
    if (searchInput) searchInput.value = '';
    
    // Show all options again
    document.querySelectorAll(`#${type}Options .searchable-dropdown-option`).forEach(opt => {
        opt.classList.remove('hidden');
    });
    
    // Update dashboard
    updateDashboard();
}

function filterDropdownOptions(type, searchTerm) {
    const options = document.querySelectorAll(`#${type}Options .searchable-dropdown-option`);
    const normalizedSearch = searchTerm.toLowerCase().trim();
    let hasVisibleOptions = false;
    
    options.forEach(option => {
        const text = option.textContent.toLowerCase();
        const value = option.dataset.value ? option.dataset.value.toLowerCase() : '';
        
        if (text.includes(normalizedSearch) || value.includes(normalizedSearch)) {
            option.classList.remove('hidden');
            hasVisibleOptions = true;
        } else {
            option.classList.add('hidden');
        }
    });
    
    // Show/hide no results message
    const noResultsMsg = document.querySelector(`#${type}Options .searchable-dropdown-no-results`);
    if (!hasVisibleOptions) {
        if (!noResultsMsg) {
            const msg = document.createElement('div');
            msg.className = 'searchable-dropdown-no-results';
            msg.textContent = 'No results found';
            document.getElementById(`${type}Options`).appendChild(msg);
        }
    } else if (noResultsMsg) {
        noResultsMsg.remove();
    }
}
        function updateBoothDropdown() {
    const boothSelect = document.getElementById('boothSelect');
    const currentValue = boothSelect.value;
    const year = document.getElementById('yearSelect').value;
    const electorate = document.getElementById('electorateSelect').value;

    const data = getCurrentData(year, 'booth', electorate, '', '');

    const booths = new Set();
    data.forEach(d => {
        if (d.b && Array.isArray(d.b)) {
            d.b.forEach(booth => {
                if (isPhysicalBooth(booth.n)) {
                    booths.add(booth.n);
                }
            });
        }
    });

    const sorted = Array.from(booths).sort();
    
    // Update searchable dropdown options
    const optionsContainer = document.getElementById('boothOptions');
    if (optionsContainer) {
        optionsContainer.innerHTML = '';
        
        // Add "All Booths" option
        const allOption = document.createElement('div');
        allOption.className = 'searchable-dropdown-option';
        allOption.dataset.value = '';
        allOption.textContent = 'All Booths';
        allOption.onclick = () => selectDropdownOption('booth', '', 'All Booths');
        if (currentValue === '') allOption.classList.add('selected');
        optionsContainer.appendChild(allOption);
        
        // Add booth options
        sorted.forEach(booth => {
            const option = document.createElement('div');
            option.className = 'searchable-dropdown-option';
            option.dataset.value = booth;
            option.textContent = booth;
            option.onclick = () => selectDropdownOption('booth', booth, booth);
            if (currentValue === booth) option.classList.add('selected');
            optionsContainer.appendChild(option);
        });
    }
    
    // Update selected text if current value exists
    if (currentValue && sorted.includes(currentValue)) {
        document.getElementById('boothSelectedText').textContent = currentValue;
        boothSelect.value = currentValue;
    } else {
        document.getElementById('boothSelectedText').textContent = 'All Booths';
        boothSelect.value = '';
    }
}
        
        function updateCandidateDropdown() {
    const candidateSelect = document.getElementById('candidateSelect');
    const currentValue = candidateSelect.value;
    const year = document.getElementById('yearSelect').value;
    const electorate = document.getElementById('electorateSelect').value;
    
    const data = getCurrentData(year, 'candidate', electorate, '', '');
    
    const candidates = [...new Set(data.map(d => d.c))].sort();
    
    // Update searchable dropdown options
    const optionsContainer = document.getElementById('candidateOptions');
    if (optionsContainer) {
        optionsContainer.innerHTML = '';
        
        // Add default option
        const defaultOption = document.createElement('div');
        defaultOption.className = 'searchable-dropdown-option';
        defaultOption.dataset.value = '';
        defaultOption.textContent = 'Select a candidate';
        defaultOption.onclick = () => selectDropdownOption('candidate', '', 'Select a candidate');
        if (currentValue === '') defaultOption.classList.add('selected');
        optionsContainer.appendChild(defaultOption);
        
        // Add candidate options
        candidates.forEach(cand => {
            const candidateData = data.find(d => d.c === cand);
            const party = candidateData ? candidateData.p : '';
            const displayText = `${cand} (${party})`;
            
            const option = document.createElement('div');
            option.className = 'searchable-dropdown-option';
            option.dataset.value = cand;
            option.innerHTML = `
                <span>${cand}</span>
                <span style="color: ${getPartyColor(party)}; margin-left: 0.5rem;">(${getPartyName(party)})</span>
            `;
            option.onclick = () => selectDropdownOption('candidate', cand, displayText);
            if (currentValue === cand) option.classList.add('selected');
            optionsContainer.appendChild(option);
        });
    }
    
    // Update selected text if current value exists
    if (currentValue && candidates.includes(currentValue)) {
        const candidateData = data.find(d => d.c === currentValue);
        const party = candidateData ? candidateData.p : '';
        document.getElementById('candidateSelectedText').textContent = `${currentValue} (${party})`;
        candidateSelect.value = currentValue;
    } else {
        document.getElementById('candidateSelectedText').textContent = 'Select a candidate';
        candidateSelect.value = '';
    }
}
        
        function renderStatewideView(container, year) {
            const seatData = currentElectionType === 'state' && SEAT_RESULTS.state[year] 
                ? SEAT_RESULTS.state[year] 
                : [];
            
            container.innerHTML = `
                <div class="panel-grid">
                    <div class="panel">
                        <h2>Party Performance</h2>
                        <div class="chart-container">
                            <canvas id="partyChart"></canvas>
                        </div>
                        <div class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Party</th>
                                        <th>Votes</th>
                                        <th>Percentage</th>
                                        <th>Seats Won</th>
                                    </tr>
                                </thead>
                                <tbody id="partyTableBody"></tbody>
                            </table>
                        </div>
                    </div>
                    
                    <div class="panel">
                        <h2>Seat Distribution</h2>
                        <div class="chart-container">
                            <canvas id="seatChart"></canvas>
                        </div>
                        <div class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Electorate</th>
                                        <th>Labor</th>
                                        <th>Liberal</th>
                                        <th>Greens</th>
                                        <th>Other</th>
                                    </tr>
                                </thead>
                                <tbody id="seatTableBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
                
                <div class="panel full-width">
                    <h2>Booth Winners Map</h2>
                    <div class="booth-filters">
                        <div class="control-group">
                            <label>Party Filter</label>
                            <div class="multi-select-container">
                                <div class="multi-select-display" onclick="togglePartyFilter()">
                                    <span id="partyFilterText">All Parties</span>
                                    <span>▼</span>
                                </div>
                                <div id="partyFilterDropdown" class="multi-select-dropdown">
                                    <div class="multi-select-option">
                                        <input type="checkbox" id="party-all" checked onchange="toggleAllParties(this)">
                                        <label for="party-all">All Parties</label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="boothMap"></div>
                    <div class="table-container" style="margin-top: 1rem;">
                        <table>
                            <thead>
                                <tr>
                                    <th>Booth</th>
                                    <th>Electorate</th>
                                    <th>Winning Party</th>
                                    <th>Votes</th>
                                </tr>
                            </thead>
                            <tbody id="boothTableBody"></tbody>
                        </table>
                    </div>
                </div>
            `;
            
            initializePartyFilter();
            loadStatewideData(year);
            
            setTimeout(() => {
                const boothWinners = calculateBoothWinners(year, '');
                if (boothWinners.length > 0) {
                    createBoothWinnersMap(boothWinners);
                    if (boothMap) {
                        boothMap.invalidateSize();
                    }
                }
            }, 200);
        }
        
        function renderElectorateView(container, year, electorate) {
            const electorateName = electorate || 'All Electorates';
            container.innerHTML = `
                <div class="panel-grid">
                    <div class="panel">
                        <h2>Party Performance - ${electorateName}</h2>
                        <div class="chart-container">
                            <canvas id="partyChart"></canvas>
                        </div>
                        <div class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Party</th>
                                        <th>Votes</th>
                                        <th>Percentage</th>
                                        <th>Candidates</th>
                                    </tr>
                                </thead>
                                <tbody id="partyTableBody"></tbody>
                            </table>
                        </div>
                    </div>
                    
                    <div class="panel">
                        <h2>Candidates - ${electorateName}</h2>
                        <div class="chart-container">
                            <canvas id="candidateChart"></canvas>
                        </div>
                        <div class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Candidate</th>
                                        <th>Party</th>
                                        <th>Votes</th>
                                        <th>Percentage</th>
                                    </tr>
                                </thead>
                                <tbody id="candidateTableBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
                
                <div class="panel full-width">
                    <h2>Booth Winners - ${electorateName}</h2>
                    <div class="booth-filters">
                        <div class="control-group">
                            <label>Party Filter</label>
                            <div class="multi-select-container">
                                <div class="multi-select-display" onclick="togglePartyFilter()">
                                    <span id="partyFilterText">All Parties</span>
                                    <span>▼</span>
                                </div>
                                <div id="partyFilterDropdown" class="multi-select-dropdown">
                                    <div class="multi-select-option">
                                        <input type="checkbox" id="party-all" checked onchange="toggleAllParties(this)">
                                        <label for="party-all">All Parties</label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="boothMap"></div>
                    <div class="table-container" style="margin-top: 1rem;">
                        <table>
                            <thead>
                                <tr>
                                    <th>Booth</th>
                                    <th>Winning Party</th>
                                    <th>Votes</th>
                                </tr>
                            </thead>
                            <tbody id="boothTableBody"></tbody>
                        </table>
                    </div>
                </div>
            `;
            
            initializePartyFilter();
            loadElectorateData(year, electorate);
            
            setTimeout(() => {
                const boothWinners = calculateBoothWinners(year, electorate);
                if (boothWinners.length > 0) {
                    createBoothWinnersMap(boothWinners);
                    if (boothMap) {
                        boothMap.invalidateSize();
                    }
                }
            }, 200);
        }
        
        function renderBoothView(container, year, electorate, booth) {
            const boothName = booth || 'All Booths';
            container.innerHTML = `
                <div class="panel full-width">
                    <h2>Booth Results - ${boothName}</h2>
                    <div class="panel-grid">
                        <div>
                            <h3>Vote Distribution</h3>
                            <div id="voteToggleGroup" style="margin: 0.25rem 0 0.5rem 0; display:flex; gap:0.5rem; flex-wrap:wrap;">
                                <button id="voteTopBtn" class="active" title="Show the top 15 candidates by votes">Top 15</button>
                                <button id="voteAllBtn" title="Show all candidates">All candidates</button>
                            </div>
                            <div class="chart-container">
                                <canvas id="voteChart"></canvas>
                            </div>
                            <h3 style="margin-top:1.5rem;">Party Vote Share Trend</h3>
                            <div class="chart-container">
                                <canvas id="boothPartyTrendChart"></canvas>
                            </div>
                            <h3 style="margin-top:1.5rem;">Detailed Results</h3>
                            <div class="table-container">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Candidate</th>
                                            <th>Party</th>
                                            <th>Votes</th>
                                            <th>Booth %</th>
                                            <th>Cand %</th>
                                        </tr>
                                    </thead>
                                    <tbody id="boothResultsBody"></tbody>
                                </table>
                            </div>
                        </div>
                        <div>
                            <h3>Booth Map</h3>
                            <div id="boothMap"></div>
                        </div>
                    </div>
                </div>
            `;

            loadBoothData(year, electorate, booth);
            createBoothPartyTrendChart(booth);
            createBoothSelectionMap(electorate, booth);
        }
        
        function renderCandidateView(container, year, candidate) {
            const candidateName = candidate || 'Select a candidate';
            const candidateData = getCurrentData(year, 'candidate', '', '', candidate)[0];
            const party = candidateData ? candidateData.p : '';
            const electorate = candidateData ? candidateData.d : '';

            container.innerHTML = `
        <div class="panel full-width">
            <h2>${candidateName}</h2>
            <p style="margin-top: -0.5rem; color: #666;">
                <span style="color: ${getPartyColor(party)}; font-weight: 600;">${getPartyName(party)}</span>
                • ${electorate} • ${currentElectionType === 'state' ? 'State Election' : 'Legislative Council'} ${year}
            </p>
            <p id="candidateSummary" style="margin-top: 0.5rem; color: #333;"></p>
        </div>

        <!-- Topline Performance -->
        <div class="panel full-width">
            <h2>Topline Performance</h2>
            <div class="booth-stats-grid">
                <div class="stat-card">
                    <h3>Primary Votes</h3>
                    <div class="stat-value" id="primaryVotes">—</div>
                    <div class="stat-label" id="primaryPercent">—</div>
                </div>
                <div class="stat-card">
                    <h3>Party Vote Share</h3>
                    <div class="stat-value" id="partyShare">—</div>
                    <div class="stat-label">of party's electorate votes</div>
                </div>
                <div class="stat-card">
                    <h3>Rank in Party</h3>
                    <div class="stat-value" id="partyRank">—</div>
                    <div class="stat-label" id="partyRankLabel">—</div>
                </div>
                <div class="stat-card">
                    <h3>Overall Rank</h3>
                    <div class="stat-value" id="overallRank">—</div>
                    <div class="stat-label" id="overallRankLabel">—</div>
                </div>
            </div>
            
            <div class="panel-grid" style="margin-top: 1.5rem;">
                <div>
                    <h3>Historical Comparison</h3>
                    <div class="table-container small">
                        <table>
                            <thead>
                                <tr>
                                    <th>Metric</th>
                                    <th>Current</th>
                                    <th>Previous</th>
                                    <th>Swing</th>
                                </tr>
                            </thead>
                            <tbody id="historicalComparisonBody">
                                <tr><td colspan="4">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <div>
                    <h3>Multi-Cycle Trend</h3>
                    <div class="chart-container small">
                        <canvas id="trendChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- Booth Performance Analysis -->
        <div class="panel full-width">
            <h2>Booth Performance Analysis</h2>
            <div class="panel-grid">
                <div>
                    <h3>Top 10 Booths</h3>
                    <div class="table-container small">
                        <table>
                            <thead>
                                <tr>
                                    <th>Booth</th>
                                    <th>Votes</th>
                                    <th>%</th>
                                    <th>Swing</th>
                                </tr>
                            </thead>
                            <tbody id="topBoothsBody">
                                <tr><td colspan="4">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <div>
                    <h3>Bottom 10 Booths</h3>
                    <div class="table-container small">
                        <table>
                            <thead>
                                <tr>
                                    <th>Booth</th>
                                    <th>Votes</th>
                                    <th>%</th>
                                    <th>Swing</th>
                                </tr>
                            </thead>
                            <tbody id="bottomBoothsBody">
                                <tr><td colspan="4">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
            
            <div style="margin-top: 1.5rem;">
                <h3>Booth Map - Candidate Performance</h3>
                <div id="boothMap"></div>
            </div>
        </div>
        
        <!-- Consistency & Distribution -->
        <div class="panel full-width">
            <h2>Consistency & Distribution Analysis</h2>
            <div class="booth-stats-grid">
                <div class="stat-card">
                    <h3>Median Booth %</h3>
                    <div class="stat-value" id="medianBooth">—</div>
                    <div class="stat-label">middle performance</div>
                </div>
                <div class="stat-card">
                    <h3>IQR</h3>
                    <div class="stat-value" id="iqrBooth">—</div>
                    <div class="stat-label">interquartile range</div>
                </div>
                <div class="stat-card">
                    <h3>Coefficient of Variation</h3>
                    <div class="stat-value" id="cvBooth">—</div>
                    <div class="stat-label">consistency measure</div>
                </div>
                <div class="stat-card">
                    <h3>Outlier Booths</h3>
                    <div class="stat-value" id="outlierCount">—</div>
                    <div class="stat-label">±2σ from mean</div>
                </div>
            </div>
            
            <div class="panel-grid" style="margin-top: 1.5rem;">
                <div>
                    <h3>Distribution of Booth Performance</h3>
                    <div class="chart-container">
                        <canvas id="distributionChart"></canvas>
                    </div>
                </div>
                <div>
                    <h3>Outlier Booths</h3>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Booth</th>
                                    <th>%</th>
                                    <th>Deviation</th>
                                    <th>Type</th>
                                </tr>
                            </thead>
                            <tbody id="outlierBoothsBody">
                                <tr><td colspan="4">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>`;

            if (candidate) {
                loadCandidateData(year, candidate);
            }
        }
        // =====================================================
// LEGISLATIVE COUNCIL SPECIFIC VIEWS
// =====================================================

function renderLCYearOverview(container, year) {
    const data = getCurrentData(year, 'state', '', '', '');
    const seatData = SEAT_RESULTS.lc[year] || [];
    
    // Calculate contested electorates and winner statistics
    const electorates = new Set(data.map(d => d.d));
    const contestedCount = electorates.size;
    
    // Calculate party performance and winners
    const partyVotes = {};
    const electorateWinners = {};
    let totalVotes = 0;
    let nonPhysicalVotes = 0;
    
    // Group by electorate to find winners
    electorates.forEach(elec => {
        const elecData = data.filter(d => d.d === elec);
        let maxVotes = 0;
        let winner = null;
        
        elecData.forEach(candidate => {
            const party = normalizeParty(candidate.p);
            if (party !== 'INF') {
                if (!partyVotes[party]) partyVotes[party] = 0;
                partyVotes[party] += candidate.v;
                totalVotes += candidate.v;
                
                if (candidate.v > maxVotes) {
                    maxVotes = candidate.v;
                    winner = { party, candidate: candidate.c, votes: candidate.v };
                }
                
                // Calculate non-physical votes
                if (candidate.b && Array.isArray(candidate.b)) {
                    candidate.b.forEach(booth => {
                        if (!isPhysicalBooth(booth.n)) {
                            nonPhysicalVotes += booth.v;
                        }
                    });
                }
            }
        });
        
        if (winner) {
            electorateWinners[elec] = winner;
        }
    });
    
    // Count electorates won by each party
    const electoratesWonByParty = {};
    Object.values(electorateWinners).forEach(winner => {
        if (!electoratesWonByParty[winner.party]) {
            electoratesWonByParty[winner.party] = 0;
        }
        electoratesWonByParty[winner.party]++;
    });
    
    const nonPhysicalPct = totalVotes > 0 ? (nonPhysicalVotes / totalVotes * 100).toFixed(1) : 0;
    
    container.innerHTML = `
        <div class="panel full-width">
            <h2>Legislative Council Year Overview - ${year}
                <span class="info-icon" data-tooltip="Legislative Council elections are held by rotation; results shown are for electorates contested in the selected year.">?</span>
            </h2>
            <div class="lc-summary-tiles">
                <div class="lc-stat-tile">
                    <h4>Contested Electorates</h4>
                    <div class="value">${contestedCount}</div>
                    <div class="sub-value">of 15 total LC electorates</div>
                </div>
                <div class="lc-stat-tile">
                    <h4>Total Votes Cast</h4>
                    <div class="value">${totalVotes.toLocaleString()}</div>
                    <div class="sub-value">across all contested</div>
                </div>
                <div class="lc-stat-tile">
                    <h4>Non-Physical Vote %</h4>
                    <div class="value">${nonPhysicalPct}%</div>
                    <div class="sub-value">postal, pre-poll, mobile</div>
                </div>
                <div class="lc-stat-tile">
                    <h4>Independent Winners</h4>
                    <div class="value">${electoratesWonByParty['IND'] || 0}</div>
                    <div class="sub-value">electorates</div>
                </div>
            </div>
        </div>
        
        <div class="panel-grid">
            <div class="panel">
                <h2>Party Performance</h2>
                <div class="chart-container">
                    <canvas id="partyChart"></canvas>
                </div>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Party</th>
                                <th>Votes</th>
                                <th>Percentage</th>
                                <th>Electorates Won</th>
                            </tr>
                        </thead>
                        <tbody id="partyTableBody"></tbody>
                    </table>
                </div>
            </div>
            
            <div class="panel">
                <h2>Electorate Winners</h2>
                <div class="chart-container">
                    <canvas id="winnerChart"></canvas>
                </div>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Electorate</th>
                                <th>Winner</th>
                                <th>Party</th>
                                <th>Votes</th>
                            </tr>
                        </thead>
                        <tbody id="winnerTableBody"></tbody>
                    </table>
                </div>
            </div>
        </div>
        
        <div class="panel full-width">
            <h2>Booth Winners Map - Contested Electorates</h2>
            <div class="booth-filters">
                <div class="control-group">
                    <label>Party Filter</label>
                    <div class="multi-select-container">
                        <div class="multi-select-display" onclick="togglePartyFilter()">
                            <span id="partyFilterText">All Parties</span>
                            <span>▼</span>
                        </div>
                        <div id="partyFilterDropdown" class="multi-select-dropdown">
                            <div class="multi-select-option">
                                <input type="checkbox" id="party-all" checked onchange="toggleAllParties(this)">
                                <label for="party-all">All Parties</label>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="control-group">
                    <label style="margin-left: 1rem;">
                        <input type="checkbox" id="showOnlyContested" checked onchange="updateDashboard()">
                        Show only contested electorates
                    </label>
                </div>
            </div>
            <div id="boothMap"></div>
        </div>
    `;
    
    // Update party table
    const partyBody = document.getElementById('partyTableBody');
    if (partyBody) {
        partyBody.innerHTML = '';
        Object.entries(partyVotes)
            .sort((a, b) => b[1] - a[1])
            .forEach(([party, votes]) => {
                const row = partyBody.insertRow();
                const electoratesWon = electoratesWonByParty[party] || 0;
                row.innerHTML = `
                    <td><span class="party-badge" style="background: ${getPartyColor(party)}">${getPartyName(party)}</span></td>
                    <td>${votes.toLocaleString()}</td>
                    <td>${((votes / totalVotes) * 100).toFixed(1)}%</td>
                    <td>${electoratesWon}</td>
                `;
            });
    }
    
    // Update winner table
    const winnerBody = document.getElementById('winnerTableBody');
    if (winnerBody) {
        winnerBody.innerHTML = '';
        Object.entries(electorateWinners).forEach(([elec, winner]) => {
            const row = winnerBody.insertRow();
            row.innerHTML = `
                <td>${elec}</td>
                <td>${winner.candidate}</td>
                <td><span class="party-badge" style="background: ${getPartyColor(winner.party)}">${getPartyName(winner.party)}</span></td>
                <td>${winner.votes.toLocaleString()}</td>
            `;
        });
    }
    
    // Create dynamic party filter
    initializeDynamicPartyFilter(data);
    
    // Create charts
    createPartyChart(partyVotes);
    createElectorateWinnerChart(electoratesWonByParty);
    
    // Create map
    setTimeout(() => {
        const boothWinners = calculateBoothWinners(year, '');
        if (boothWinners.length > 0) {
            createBoothWinnersMap(boothWinners);
            if (boothMap) {
                boothMap.invalidateSize();
            }
        }
    }, 200);
}

function renderLCElectorateView(container, year, electorate) {
    const electorateName = electorate || 'All Contested Electorates';
    const data = getCurrentData(year, 'electorate', electorate, '', '');
    
    // For LC, calculate TCP if we have final two candidates
    const candidates = [...data].sort((a, b) => b.v - a.v);
    const hasRunoff = candidates.length >= 2;
    const winner = candidates[0];
    const runnerUp = candidates[1];
    
    // Calculate statistics
    const totalVotes = data.reduce((sum, c) => sum + c.v, 0);
    const tcpMargin = hasRunoff ? ((winner.v - runnerUp.v) / totalVotes * 100).toFixed(2) : null;
    
    // Get previous election data for swing calculation
    const prevYear = getPreviousLCElectionYear(electorate, parseInt(year));
    let swing = null;
    if (prevYear && winner) {
        const prevData = ELECTION_DATA.lc[prevYear];
        if (prevData) {
            const prevWinner = prevData.filter(d => d.d === electorate)
                .sort((a, b) => b.v - a.v)[0];
            if (prevWinner) {
                const prevTotal = prevData.filter(d => d.d === electorate)
                    .reduce((sum, c) => sum + c.v, 0);
                const prevPct = (prevWinner.v / prevTotal * 100);
                const currPct = (winner.v / totalVotes * 100);
                swing = (currPct - prevPct).toFixed(2);
            }
        }
    }
    
    container.innerHTML = `
        <div class="panel full-width">
            <h2>Legislative Council Electorate - ${electorateName}</h2>
            ${electorate ? `
            <div class="lc-summary-tiles">
                <div class="lc-stat-tile">
                    <h4>Primary Lead</h4>
                    <div class="value">${winner ? winner.c : 'N/A'}</div>
                    <div class="sub-value">${winner ? `${getPartyName(winner.p)} - ${((winner.v / totalVotes) * 100).toFixed(1)}%` : ''}</div>
                </div>
                <div class="lc-stat-tile">
                    <h4>TCP Margin</h4>
                    <div class="value">${tcpMargin ? tcpMargin + '%' : 'N/A'}</div>
                    <div class="sub-value">${hasRunoff ? `${winner.c} vs ${runnerUp.c}` : 'Single candidate'}</div>
                </div>
                <div class="lc-stat-tile">
                    <h4>Swing vs ${prevYear || 'Previous'}</h4>
                    <div class="value" style="color: ${swing > 0 ? 'green' : swing < 0 ? 'red' : 'inherit'}">
                        ${swing ? (swing > 0 ? '+' : '') + swing + '%' : 'N/A'}
                    </div>
                    <div class="sub-value">from previous LC contest</div>
                </div>
                <div class="lc-stat-tile">
                    <h4>Total Turnout</h4>
                    <div class="value">${totalVotes.toLocaleString()}</div>
                    <div class="sub-value">valid votes cast</div>
                </div>
            </div>
            ` : ''}
        </div>
        
        <div class="panel-grid">
            <div class="panel">
                <h2>Candidate Performance</h2>
                <div class="chart-container">
                    <canvas id="candidateChart"></canvas>
                </div>
                <div class="table-container">
                    <table>
                        <thead>
                            <tr>
                                <th>Candidate</th>
                                <th>Party</th>
                                <th>Primary Votes</th>
                                <th>%</th>
                            </tr>
                        </thead>
                        <tbody id="candidateTableBody"></tbody>
                    </table>
                </div>
            </div>
            
            <div class="panel">
                <h2>Booth Performance</h2>
                <div class="chart-container">
                    <canvas id="boothTCPChart"></canvas>
                </div>
            </div>
        </div>
        
        <div class="panel full-width">
            <h2>Booth Winners Map</h2>
            <div id="boothMap"></div>
        </div>
    `;
    
    // Update tables
    const candidateBody = document.getElementById('candidateTableBody');
    if (candidateBody) {
        candidateBody.innerHTML = '';
        candidates.forEach(cand => {
            const row = candidateBody.insertRow();
            row.innerHTML = `
                <td>${cand.c}</td>
                <td style="color: ${getPartyColor(cand.p)}">${getPartyName(cand.p)}</td>
                <td>${cand.v.toLocaleString()}</td>
                <td>${((cand.v / totalVotes) * 100).toFixed(2)}%</td>
            `;
        });
    }
    
    // Create charts
    createCandidateChart(candidates.slice(0, 10));
    if (hasRunoff && electorate) {
        createBoothTCPChart(winner, runnerUp, data);
    }
    
    // Create map
    setTimeout(() => {
        const boothWinners = calculateBoothWinners(year, electorate);
        if (boothWinners.length > 0) {
            createBoothWinnersMap(boothWinners);
            if (boothMap) {
                boothMap.invalidateSize();
            }
        }
    }, 200);
}

function renderLCCandidateView(container, year, candidate) {
    const candidateData = getCurrentData(year, 'candidate', '', '', candidate)[0];
    
    if (!candidateData) {
        container.innerHTML = `
            <div class="panel full-width">
                <h2>Select a Candidate</h2>
                <p>Please select a candidate from the dropdown above.</p>
            </div>
        `;
        return;
    }
    
    const electorate = candidateData.d;
    const party = candidateData.p;
    const electorateData = getCurrentData(year, 'electorate', electorate, '', '');
    
    // Calculate LC-specific metrics
    const totalVotes = electorateData.reduce((sum, c) => sum + c.v, 0);
    const primaryPct = (candidateData.v / totalVotes * 100).toFixed(2);
    
    // Check if this candidate was the winner
    const sortedCandidates = [...electorateData].sort((a, b) => b.v - a.v);
    const rank = sortedCandidates.findIndex(c => c.c === candidate) + 1;
    const isWinner = rank === 1;
    const isRunnerUp = rank === 2;
    
    // TCP calculation if relevant
    let tcpPct = null;
    let tcpMargin = null;
    if (isWinner && sortedCandidates.length >= 2) {
        const runnerUp = sortedCandidates[1];
        tcpMargin = ((candidateData.v - runnerUp.v) / totalVotes * 100).toFixed(2);
        tcpPct = (candidateData.v / (candidateData.v + runnerUp.v) * 100).toFixed(2);
    }
    
    // Previous election comparison
    const prevYear = getPreviousLCElectionYear(electorate, parseInt(year));
    let swing = null;
    if (prevYear) {
        const prevData = ELECTION_DATA.lc[prevYear];
        if (prevData) {
            const prevCandidate = prevData.find(c => c.c === candidate && c.d === electorate);
            if (prevCandidate) {
                const prevTotal = prevData.filter(d => d.d === electorate)
                    .reduce((sum, c) => sum + c.v, 0);
                const prevPct = (prevCandidate.v / prevTotal * 100);
                swing = (parseFloat(primaryPct) - prevPct).toFixed(2);
            }
        }
    }
    
    // Calculate postal and pre-poll share
    let postalVotes = 0;
    let prePollVotes = 0;
    if (candidateData.b && Array.isArray(candidateData.b)) {
        candidateData.b.forEach(booth => {
            const lower = booth.n.toLowerCase();
            if (lower.includes('postal')) postalVotes += booth.v;
            if (lower.includes('pre-poll') || lower.includes('prepoll')) prePollVotes += booth.v;
        });
    }
    
    container.innerHTML = `
        <div class="panel full-width">
            <h2>${candidate}</h2>
            <p style="margin-top: -0.5rem; color: #666;">
                <span style="color: ${getPartyColor(party)}; font-weight: 600;">${getPartyName(party)}</span>
                • ${electorate} • Legislative Council ${year}
            </p>
        </div>
        
        <div class="panel full-width">
            <h2>Performance Metrics</h2>
            <div class="booth-stats-grid">
                <div class="stat-card">
                    <h3>Primary Vote %</h3>
                    <div class="stat-value">${primaryPct}%</div>
                    <div class="stat-label">${candidateData.v.toLocaleString()} votes</div>
                </div>
                ${isWinner ? `
                <div class="stat-card">
                    <h3>Final TCP %</h3>
                    <div class="stat-value">${tcpPct || 'N/A'}%</div>
                    <div class="stat-label">two-candidate preferred</div>
                </div>
                <div class="stat-card">
                    <h3>TCP Margin</h3>
                    <div class="stat-value">${tcpMargin || 'N/A'}%</div>
                    <div class="stat-label">winning margin</div>
                </div>
                ` : `
                <div class="stat-card">
                    <h3>Position</h3>
                    <div class="stat-value">#${rank}</div>
                    <div class="stat-label">of ${sortedCandidates.length} candidates</div>
                </div>
                <div class="stat-card">
                    <h3>Margin Behind</h3>
                    <div class="stat-value">${((sortedCandidates[0].v - candidateData.v) / totalVotes * 100).toFixed(2)}%</div>
                    <div class="stat-label">behind winner</div>
                </div>
                `}
                <div class="stat-card">
                    <h3>Swing vs ${prevYear || 'Previous'}</h3>
                    <div class="stat-value" style="color: ${swing > 0 ? 'green' : swing < 0 ? 'red' : 'inherit'}">
                        ${swing ? (swing > 0 ? '+' : '') + swing + '%' : 'N/A'}
                    </div>
                    <div class="stat-label">from previous LC contest</div>
                </div>
                <div class="stat-card">
                    <h3>${prevYear && swing ? 'Incumbent' : 'New Candidate'}</h3>
                    <div class="stat-value">${prevYear && swing ? 'Yes' : 'No'}</div>
                    <div class="stat-label">contested previously</div>
                </div>
                <div class="stat-card">
                    <h3>Postal Share</h3>
                    <div class="stat-value">${((postalVotes / candidateData.v) * 100).toFixed(1)}%</div>
                    <div class="stat-label">${postalVotes.toLocaleString()} postal votes</div>
                </div>
                <div class="stat-card">
                    <h3>Pre-poll Share</h3>
                    <div class="stat-value">${((prePollVotes / candidateData.v) * 100).toFixed(1)}%</div>
                    <div class="stat-label">${prePollVotes.toLocaleString()} pre-poll votes</div>
                </div>
            </div>
        </div>
        
        <div class="panel full-width">
            <h2>Booth Performance</h2>
            <div class="panel-grid">
                <div>
                    <h3>Top Performing Booths</h3>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Booth</th>
                                    <th>Votes</th>
                                    <th>%</th>
                                </tr>
                            </thead>
                            <tbody id="topBoothsBody"></tbody>
                        </table>
                    </div>
                </div>
                <div>
                    <h3>Performance Distribution</h3>
                    <div class="chart-container">
                        <canvas id="distributionChart"></canvas>
                    </div>
                </div>
            </div>
        </div>
        
        <div class="panel full-width">
            <h2>Booth Map - Candidate Performance</h2>
            <div id="boothMap"></div>
        </div>
    `;
    
    // Load booth performance data
    loadLCCandidateBoothData(candidateData, electorateData);
}

function loadLCCandidateBoothData(candidateData, electorateData) {
    const boothPerformance = [];
    
    if (candidateData.b && Array.isArray(candidateData.b)) {
        candidateData.b.forEach(booth => {
            if (isPhysicalBooth(booth.n)) {
                // Calculate total votes at this booth
                let boothTotal = 0;
                electorateData.forEach(c => {
                    const b = (c.b || []).find(b => b.n === booth.n);
                    if (b) boothTotal += b.v;
                });
                
                const pct = boothTotal > 0 ? (booth.v / boothTotal * 100) : 0;
                boothPerformance.push({
                    name: booth.n,
                    votes: booth.v,
                    percentage: pct,
                    total: boothTotal
                });
            }
        });
    }
    
    // Sort by percentage
    boothPerformance.sort((a, b) => b.percentage - a.percentage);
    
    // Update top booths table
    const topBody = document.getElementById('topBoothsBody');
    if (topBody) {
        topBody.innerHTML = '';
        boothPerformance.slice(0, 10).forEach(booth => {
            const row = topBody.insertRow();
            row.innerHTML = `
                <td>${booth.name}</td>
                <td>${booth.votes.toLocaleString()}</td>
                <td>${booth.percentage.toFixed(1)}%</td>
            `;
        });
    }
    
    // Create distribution chart
    createDistributionChart(boothPerformance);
    
    // Create map
    createCandidateBoothMap(boothPerformance, candidateData.d);
}

function createBoothTCPChart(winner, runnerUp, electorateData) {
    const ctx = document.getElementById('boothTCPChart');
    if (!ctx) return;
    
    const boothResults = [];
    
    // Get all booths
    const booths = new Set();
    electorateData.forEach(candidate => {
        if (candidate.b && Array.isArray(candidate.b)) {
            candidate.b.forEach(booth => {
                if (isPhysicalBooth(booth.n)) {
                    booths.add(booth.n);
                }
            });
        }
    });
    
    // Calculate TCP for each booth
    booths.forEach(boothName => {
        const winnerBooth = winner.b ? winner.b.find(b => b.n === boothName) : null;
        const runnerUpBooth = runnerUp.b ? runnerUp.b.find(b => b.n === boothName) : null;
        
        if (winnerBooth || runnerUpBooth) {
            const winnerVotes = winnerBooth ? winnerBooth.v : 0;
            const runnerUpVotes = runnerUpBooth ? runnerUpBooth.v : 0;
            const total = winnerVotes + runnerUpVotes;
            
            if (total > 0) {
                boothResults.push({
                    booth: boothName,
                    winnerPct: (winnerVotes / total * 100),
                    runnerUpPct: (runnerUpVotes / total * 100)
                });
            }
        }
    });
    
    // Sort by winner percentage
    boothResults.sort((a, b) => b.winnerPct - a.winnerPct);
    
    if (charts.boothTCP) charts.boothTCP.destroy();
    
    charts.boothTCP = new Chart(ctx.getContext('2d'), {
        type: 'bar',
        data: {
            labels: boothResults.slice(0, 15).map(r => r.booth),
            datasets: [
                {
                    label: winner.c,
                    data: boothResults.slice(0, 15).map(r => r.winnerPct),
                    backgroundColor: getPartyColor(winner.p)
                },
                {
                    label: runnerUp.c,
                    data: boothResults.slice(0, 15).map(r => r.runnerUpPct),
                    backgroundColor: getPartyColor(runnerUp.p)
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' },
                title: {
                    display: true,
                    text: 'TCP by Booth (Top 15)'
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: 100,
                    ticks: { callback: value => value + '%' }
                }
            }
        }
    });
}

function createElectorateWinnerChart(electoratesWonByParty) {
    const ctx = document.getElementById('winnerChart');
    if (!ctx) return;
    
    const sorted = Object.entries(electoratesWonByParty)
        .sort((a, b) => b[1] - a[1]);
    
    if (charts.winner) charts.winner.destroy();
    
    charts.winner = new Chart(ctx.getContext('2d'), {
        type: 'doughnut',
        data: {
            labels: sorted.map(([party]) => getPartyName(party)),
            datasets: [{
                data: sorted.map(([, count]) => count),
                backgroundColor: sorted.map(([party]) => getPartyColor(party))
            }]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' }
            }
        }
    });
}

function initializeDynamicPartyFilter(data) {
    const dropdown = document.getElementById('partyFilterDropdown');
    if (!dropdown) return;
    
    // Keep the "All" option
    while (dropdown.children.length > 1) {
        dropdown.removeChild(dropdown.lastChild);
    }
    
    // Build party list from current data
    const parties = new Set();
    data.forEach(row => {
        const party = normalizeParty(row.p);
        if (party !== 'INF') {
            parties.add(party);
        }
    });
    
    const sortedParties = Array.from(parties).sort();
    
    sortedParties.forEach(party => {
        const option = document.createElement('div');
        option.className = 'multi-select-option';
        option.innerHTML = `
            <input type="checkbox" id="party-${party}" value="${party}" checked onchange="updatePartyFilter()">
            <label for="party-${party}" style="color: ${getPartyColor(party)}">${getPartyName(party)}</label>
        `;
        dropdown.appendChild(option);
    });
}
        
        // ==========================================
        // Booth Analysis (rank shifts between years)
        // ==========================================
        function getAvailableYears() {
            const bucket = (currentElectionType === 'state') ? ELECTION_DATA.state : ELECTION_DATA.lc;
            return Object.keys(bucket || {}).filter(y => (bucket[y] || []).length > 0).map(y => parseInt(y,10)).sort((a,b)=>a-b);
        }
        function getPreviousYear(currentYear) {
            const years = getAvailableYears();
            const y = parseInt(currentYear, 10);
            let prev = null;
            for (let i = years.length - 1; i >= 0; i--) {
                if (years[i] < y) { prev = years[i]; break; }
            }
            return prev;
        }
        function aggregateBoothPartyVotes(year, electorateFilter) {
            const data = (currentElectionType === 'state') ? ELECTION_DATA.state[year] : ELECTION_DATA.lc[year];
            if (!data) return {};
            const booths = {};
            const useElectorate = electorateFilter && electorateFilter !== '';
            (useElectorate ? data.filter(d => d.d === electorateFilter) : data).forEach(candidate => {
                if (candidate.b && Array.isArray(candidate.b)) {
                    candidate.b.forEach(booth => {
                        const boothName = booth.n;
                        if (!isPhysicalBooth(boothName)) return;
                        const key = (typeof keyForBooth === 'function') ? keyForBooth(boothName) : boothName;
                        if (!booths[key]) {
                            booths[key] = { name: boothName, electorate: candidate.d, parties: {} };
                        }
                        const party = normalizeParty(candidate.p);
                        if (party === 'INF') return; // exclude Informal from ranking
                        booths[key].parties[party] = (booths[key].parties[party] || 0) + (booth.v || 0);
                    });
                }
            });
            return booths;
        }
        function ranksFromPartyVotes(partyVotes) {
            // returns {party->rank} and rank order array
            const entries = Object.entries(partyVotes || {}).sort((a,b)=>b[1]-a[1]);
            const ranks = {};
            let rank = 1;
            entries.forEach(([p,_votes], idx) => {
                if (idx > 0 && entries[idx-1][1] !== _votes) rank = idx+1; // dense ranking
                ranks[p] = rank;
            });
            return { ranks, order: entries.map(e=>e[0]) };
        }
        function computeBoothRankShifts(currYear, prevYear, electorateFilter) {
            const curr = aggregateBoothPartyVotes(currYear, electorateFilter);
            const prev = prevYear ? aggregateBoothPartyVotes(prevYear, electorateFilter) : {};
            
            const partiesSet = new Set();
            const partyStats = {}; // per party aggregates
            const topChanges = []; // booths where #1 changed
            let boothsConsidered = 0;
            let boothsWithAnyChange = 0;
            
            // helper to init party stats
            function ensureParty(p){
                if (!partyStats[p]) partyStats[p] = { gainedFirst:0, lostFirst:0, netRankDelta:0 };
            }
            
            Object.keys(curr).forEach(key => {
                if (!prev[key]) return; // compare only if booth exists in both years
                const c = curr[key], p = prev[key];
                const cr = ranksFromPartyVotes(c.parties);
                const pr = ranksFromPartyVotes(p.parties);
                
                boothsConsidered++;
                let anyChange = false;
                
                // union of parties present across both
                const allParties = new Set([...Object.keys(c.parties||{}), ...Object.keys(p.parties||{})]);
                allParties.forEach(pt => {
                    ensureParty(pt);
                    const r0 = pr.ranks[pt];
                    const r1 = cr.ranks[pt];
                    if (r0 != null && r1 != null) {
                        const delta = (r0 - r1); // + means improved rank
                        partyStats[pt].netRankDelta += delta;
                        if (delta !== 0) anyChange = true;
                        if (r0 === 1 && r1 !== 1) partyStats[pt].lostFirst += 1;
                        if (r0 !== 1 && r1 === 1) partyStats[pt].gainedFirst += 1;
                    }
                });
                
                const prevTop = pr.order[0] || null;
                const currTop = cr.order[0] || null;
                if (prevTop && currTop && prevTop !== currTop) {
                    topChanges.push({
                        booth: c.name,
                        electorate: c.electorate,
                        prevTop,
                        currTop
                    });
                    anyChange = true;
                }
                if (anyChange) boothsWithAnyChange++;
            });
            
            // build party arrays
            const parties = Array.from(new Set([...Object.keys(partyStats)])).sort();
            const statsArray = parties.map(p => ({ party: p, ...partyStats[p] }));
            return {
                parties, partyStats, statsArray,
                topChanges,
                boothsConsidered, boothsWithAnyChange
            };
        }
        
        function renderBoothAnalysisView(container, year, electorate) {
    const prevYear = currentElectionType === 'lc' && electorate 
        ? getPreviousLCElectionYear(electorate, parseInt(year))
        : getPreviousYear(year);
    const scopeName = electorate && electorate !== '' ? electorate : (currentElectionType === 'lc' ? 'Year Overview' : 'Statewide');
    
    container.innerHTML = `
        <div class="panel full-width">
            <h2>Booth Analysis – ${scopeName} <span title="Ranks are based on total primary votes per party at each physical booth (summing candidates per party). We compare the selected year to the previous election of the same type. Informal and non-physical booths are excluded.">ℹ</span></h2>
            <p style="margin-bottom: 0.75rem; color: #666;">Comparing <strong>${prevYear || '—'}</strong> → <strong>${year}</strong> (${currentElectionType.toUpperCase()})</p>
            <div class="panel-grid">
                <div class="panel">
                    <h3>First-Place Gains & Losses by Party</h3>
                    <div class="chart-container">
                        <canvas id="rankShiftChart"></canvas>
                    </div>
                </div>
                <div class="panel">
                    <h3>Summary</h3>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Metric</th>
                                    <th>Value</th>
                                </tr>
                            </thead>
                            <tbody id="boothAnalysisSummaryBody">
                                <tr><td>Total booths compared</td><td>—</td></tr>
                                <tr><td>Booths with any rank change</td><td>—</td></tr>
                                <tr><td>Share with change</td><td>—</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>
        <div class="panel full-width">
            <h2>Booths where #1 party changed</h2>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Booth</th>
                            <th>Electorate</th>
                            <th>#1 in ${prevYear || 'prev'}</th>
                            <th>#1 in ${year}</th>
                        </tr>
                    </thead>
                    <tbody id="boothTopChangeBody">
                        <tr><td colspan="4">Loading...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
    `;
    
    loadBoothAnalysisData(year, prevYear, electorate);
}
        
        function loadBoothAnalysisData(year, prevYear, electorate) {
            const res = computeBoothRankShifts(parseInt(year,10), prevYear ? parseInt(prevYear,10) : null, electorate);
            
            // Update summary table
            const summaryBody = document.getElementById('boothAnalysisSummaryBody');
            if (summaryBody) {
                const total = res.boothsConsidered;
                const changed = res.boothsWithAnyChange;
                const share = total > 0 ? ((changed/total)*100).toFixed(1) + '%' : '—';
                summaryBody.innerHTML = `
                    <tr><td>Total booths compared</td><td>${total}</td></tr>
                    <tr><td>Booths with any rank change</td><td>${changed}</td></tr>
                    <tr><td>Share with change</td><td>${share}</td></tr>
                `;
            }
            
            // Build chart datasets for gains/losses
            const parties = res.statsArray.map(s => s.party);
            const labels = parties.map(p => getPartyName(p));
            const gains = res.statsArray.map(s => s.gainedFirst);
            const losses = res.statsArray.map(s => s.lostFirst);
            
            const ctx = document.getElementById('rankShiftChart');
            if (ctx) {
                if (charts.rankShift) charts.rankShift.destroy();
                charts.rankShift = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels,
                        datasets: [
                            {
                                label: 'Gains to 1st',
                                data: gains,
                                backgroundColor: parties.map(p => getPartyColor(p)),
                                borderWidth: 1
                            },
                            {
                                label: 'Losses from 1st',
                                data: losses,
                                backgroundColor: parties.map(p => getPartyColor(p)),
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                    plugins: { legend: { display: false } },
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { stacked: false },
                            y: { beginAtZero: true, ticks: { precision: 0 } }
                        }
                    }
                });
            }
            
            // Top changes table
            const tbody = document.getElementById('boothTopChangeBody');
            if (tbody) {
                if (res.topChanges.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4">No booths changed #1 party for the selected comparison.</td></tr>';
                } else {
                    // Sort by party name then booth for stable display
                    const rows = res.topChanges
                        .slice()
                        .sort((a,b)=> (a.currTop.localeCompare(b.currTop) || a.booth.localeCompare(b.booth)))
                        .map(ch => `
                            <tr>
                                <td>${ch.booth}</td>
                                <td>${ch.electorate}</td>
                                <td><span style="display:inline-block;width:10px;height:10px;background:${getPartyColor(ch.prevTop)};margin-right:6px;border-radius:2px;"></span>${getPartyName(ch.prevTop)}</td>
                                <td><span style="display:inline-block;width:10px;height:10px;background:${getPartyColor(ch.currTop)};margin-right:6px;border-radius:2px;"></span>${getPartyName(ch.currTop)}</td>
                            </tr>
                        `).join('');
                    tbody.innerHTML = rows;
                }
            }
        }
function renderHistoricalView(container) {
    const years = getAvailableYears();
    if (years.length === 0) {
        container.innerHTML = `
            <div class="panel full-width">
                <h2>Historical Overview</h2>
                <p style="color: #d32f2f;">No data available for historical analysis</p>
            </div>
        `;
        return;
    }

    // For LC historical view, add cohort toggle
    const lcHistoricalControls = currentElectionType === 'lc' ? `
    <div style="margin-bottom: 1rem; padding: 1rem; background: var(--federal-light); border-radius: 8px;">
        <label style="margin-right: 1rem;">View Mode:</label>
        <button id="lcAggregateBtn" class="active" onclick="toggleLCHistoricalMode('aggregate')">All Divisions Aggregate</button>
        <button id="lcDivisionBtn" onclick="toggleLCHistoricalMode('division')">Single Division History</button>
        <select id="lcDivisionSelect" style="display: none; margin-left: 1rem;" onchange="updateLCDivisionView()">
            <option value="">Select division</option>
        </select>
    </div>
` : '';

    // Build the comprehensive historical view with tooltips
    container.innerHTML = `
        <div class="panel full-width">
            <h2>Historical Overview - ${currentElectionType === 'state' ? 'State Elections' : 'Legislative Council'}</h2>
            <p style="margin-bottom: 1rem; color: #666;">
                ${currentElectionType === 'lc' 
                    ? 'Analysis of Legislative Council elections across rotation cycles. Note: electorates vote on different years.'
                    : 'Comprehensive analysis of party performance, seat distribution, and electoral dynamics over time'}
            </p>
            ${lcHistoricalControls}
        </div>

        <!-- Statewide Trends -->
        <div class="panel full-width">
            <h2>${currentElectionType === 'lc' ? 'Contested Electorate' : 'Statewide'} Trends</h2>
            <div class="panel-grid">
                <div>
                    <h3>First Preference Vote Share Over Time
                        <span class="info-icon" data-tooltip="Shows the percentage of total first preference votes received by each party across all elections. ${currentElectionType === 'lc' ? 'For LC, only includes contested electorates for each year.' : 'Calculated as: (Party Votes ÷ Total Valid Votes) × 100'}">?</span>
                    </h3>
                    <div class="chart-container">
                        <canvas id="voteTrendChart"></canvas>
                    </div>
                </div>
                ${currentElectionType === 'state' ? `
                <div>
                    <h3>Seats Held by Party Over Time
                        <span class="info-icon" data-tooltip="Total number of seats won by each party in each election. Based on final seat allocation after preference distribution.">?</span>
                    </h3>
                    <div class="chart-container">
                        <canvas id="seatTrendChart"></canvas>
                    </div>
                </div>
                ` : `
                <div>
                    <h3 id="electorateWinChartTitle">Electorates Won by Party Over Time
    <span class="info-icon" data-tooltip="Number of LC electorates won by each party/independent in contested elections each year. When viewing a single division, shows winning margins over time.">?</span>
</h3>
                    <div class="chart-container">
                        <canvas id="electorateWinChart"></canvas>
                    </div>
                </div>
                `}
            </div>
        </div>

        <!-- Year Overview Table -->
        <div class="panel full-width">
            <h2>Year-by-Year Summary</h2>
            <div class="table-container">
                <table>
                    <thead>
                        <tr>
                            <th>Year</th>
                            ${currentElectionType === 'lc' ? '<th>Contested</th>' : ''}
                            <th>Total Votes</th>
                            <th>Labor %</th>
                            <th>Liberal %</th>
                            <th>Greens %</th>
                            <th>Independent %</th>
                            ${currentElectionType === 'state' ? '<th>Total Seats</th>' : '<th>Electorates Won</th>'}
                            <th>ENP
                                <span class="info-icon" data-tooltip="Effective Number of Parties: Measures party system fragmentation. Calculated as 1 ÷ Σ(vote share²). Higher values indicate more competitive multi-party system.">?</span>
                            </th>
                            <th>Non-Physical %
                                <span class="info-icon" data-tooltip="Percentage of votes cast through non-physical methods including postal votes, pre-poll votes, mobile booths, and provisional votes.">?</span>
                            </th>
                        </tr>
                    </thead>
                    <tbody id="yearOverviewBody">
                        <tr><td colspan="${currentElectionType === 'state' ? 9 : 10}">Loading...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>

        <!-- Party Performance Metrics -->
        <div class="panel full-width">
            <h2>Party Performance Extremes
                <span class="info-icon" data-tooltip="Shows the highest and lowest vote share percentages achieved by each party across all elections in the dataset. ${currentElectionType === 'lc' ? 'Note: LC results only include contested electorates.' : ''}">?</span>
            </h2>
            <div class="panel-grid">
                <div>
                    <h3>Best Performances</h3>
                    <div class="table-container small">
                        <table>
                            <thead>
                                <tr>
                                    <th>Party</th>
                                    <th>Best %</th>
                                    <th>Year</th>
                                </tr>
                            </thead>
                            <tbody id="partyBestBody">
                                <tr><td colspan="3">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <div>
                    <h3>Worst Performances</h3>
                    <div class="table-container small">
                        <table>
                            <thead>
                                <tr>
                                    <th>Party</th>
                                    <th>Worst %</th>
                                    <th>Year</th>
                                </tr>
                            </thead>
                            <tbody id="partyWorstBody">
                                <tr><td colspan="3">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Electorate-Level Analysis -->
        <div class="panel full-width">
            <h2>Electorate-Level Trends</h2>
            <div style="margin-bottom: 1rem;">
                <label style="margin-right: 1rem;">Select Electorate: </label>
                <select id="historicalElectorateSelect" onchange="updateHistoricalElectorateCharts()">
                    <option value="">Loading...</option>
                </select>
            </div>
            <div class="panel-grid">
                <div>
                    <h3>Party Vote Share by Electorate</h3>
                    <div class="chart-container">
                        <canvas id="electorateVoteTrendChart"></canvas>
                    </div>
                </div>
                <div>
                    <h3>Electorate Stability Index
                        <span class="info-icon" data-tooltip="Volatility score measures average absolute swing in party vote shares between consecutive elections. ${currentElectionType === 'lc' ? 'For LC, compares only when the same electorate contests.' : ''} Lower values indicate more stable voting patterns. Green: stable (<3), Orange: moderate (3-5), Red: volatile (>5).">?</span>
                    </h3>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Electorate</th>
                                    <th>Volatility</th>
                                    <th>Leading Party</th>
                                    <th>Trend</th>
                                </tr>
                            </thead>
                            <tbody id="electorateStabilityBody">
                                <tr><td colspan="4">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Swing Analysis -->
        <div class="panel full-width">
            <h2>Swing Analysis
                <span class="info-icon" data-tooltip="Calculates the change in party vote share between two elections. ${currentElectionType === 'lc' ? 'For LC, only compares electorates that contested in both years.' : ''} Swing = (Party % in Year 2) - (Party % in Year 1). Positive values indicate gains, negative values indicate losses.">?</span>
            </h2>
            <div style="margin-bottom: 1rem;">
                <label style="margin-right: 1rem;">Compare Years: </label>
                <select id="swingFromYear" onchange="updateSwingAnalysis()">
                    <option value="">From Year</option>
                </select>
                <span style="margin: 0 1rem;">→</span>
                <select id="swingToYear" onchange="updateSwingAnalysis()">
                    <option value="">To Year</option>
                </select>
                <label style="margin-left: 2rem;">Party: </label>
                <select id="swingParty" onchange="updateSwingAnalysis()">
                    <option value="ALP">Labor</option>
                    <option value="LIB">Liberal</option>
                    <option value="GRN">Greens</option>
                    <option value="IND">Independent</option>
                </select>
            </div>
            <div class="panel-grid">
                <div>
                    <h3>Top 10 Positive Swings</h3>
                    <div class="table-container small">
                        <table>
                            <thead>
                                <tr>
                                    <th>Electorate</th>
                                    <th>Swing</th>
                                    <th>Final %</th>
                                </tr>
                            </thead>
                            <tbody id="topSwingsBody">
                                <tr><td colspan="3">Select years to compare</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
                <div>
                    <h3>Top 10 Negative Swings</h3>
                    <div class="table-container small">
                        <table>
                            <thead>
                                <tr>
                                    <th>Electorate</th>
                                    <th>Swing</th>
                                    <th>Final %</th>
                                </tr>
                            </thead>
                            <tbody id="bottomSwingsBody">
                                <tr><td colspan="3">Select years to compare</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            </div>
        </div>

        <!-- Booth-Level Historical Insights -->
        <div class="panel full-width">
            <h2>Booth-Level Historical Insights</h2>
            <div class="panel-grid">
                <div>
                    <h3>Share of Booths Won by Party
                        <span class="info-icon" data-tooltip="Percentage of physical polling booths where each party received the most votes. ${currentElectionType === 'lc' ? 'For LC, only includes booths in contested electorates.' : ''} Excludes postal and pre-poll votes. Based on primary vote totals at each booth.">?</span>
                    </h3>
                    <div class="chart-container">
                        <canvas id="boothShareChart"></canvas>
                    </div>
                </div>
                <div>
                    <h3>Non-Physical vs Physical Vote Share
                        <span class="info-icon" data-tooltip="Tracks the proportion of votes cast at physical polling booths versus alternative methods (postal, pre-poll, mobile, provisional) over time.">?</span>
                    </h3>
                    <div class="chart-container">
                        <canvas id="voteTypeChart"></canvas>
                    </div>
                </div>
            </div>
        </div>

        <!-- Booth Flips Timeline -->
        <div class="panel full-width">
            <h2>Booth Flips Over Time
                <span class="info-icon" data-tooltip="Shows polling booths where the winning party changed between consecutive elections. ${currentElectionType === 'lc' ? 'For LC, compares the same electorate between its current year and its previous LC contest.' : 'A flip occurs when the party with the most votes at a booth differs from the previous election.'}">?</span>
            </h2>
            <div class="chart-container">
                <canvas id="boothFlipsChart"></canvas>
            </div>
            <div class="table-container" style="margin-top: 1rem;">
                <table>
                    <thead>
                        <tr>
                            <th>Transition</th>
                            <th>Total Flips</th>
                            <th>To Labor</th>
                            <th>To Liberal</th>
                            <th>To Greens</th>
                            <th>To Independent</th>
                        </tr>
                    </thead>
                    <tbody id="boothFlipsTableBody">
                        <tr><td colspan="6">Loading...</td></tr>
                    </tbody>
                </table>
            </div>
        </div>
    `;

    // Load all historical data
    loadHistoricalData();
}

// Historical data functions
function loadHistoricalData() {
    const years = getAvailableYears();
    
    // Populate year selectors
    const swingFromSelect = document.getElementById('swingFromYear');
    const swingToSelect = document.getElementById('swingToYear');
    if (swingFromSelect && swingToSelect) {
        swingFromSelect.innerHTML = '<option value="">From Year</option>';
        swingToSelect.innerHTML = '<option value="">To Year</option>';
        years.forEach(year => {
            swingFromSelect.innerHTML += `<option value="${year}">${year}</option>`;
            swingToSelect.innerHTML += `<option value="${year}">${year}</option>`;
        });
    }
    
    // Populate electorate selector
    const electorateSelect = document.getElementById('historicalElectorateSelect');
    if (electorateSelect) {
        const allElectorates = new Set();
        years.forEach(year => {
            const data = currentElectionType === 'state' 
                ? ELECTION_DATA.state[year] 
                : ELECTION_DATA.lc[year];
            if (data) {
                data.forEach(d => allElectorates.add(d.d));
            }
        });
        electorateSelect.innerHTML = '<option value="">All Electorates</option>';
        [...allElectorates].sort().forEach(elec => {
            electorateSelect.innerHTML += `<option value="${elec}">${elec}</option>`;
        });
    }
    
    // Load all trend data
    createVoteTrendChart();
    if (currentElectionType === 'state') {
        createSeatTrendChart();
    } else {
        createLCElectorateWinTrendChart();
    }
    createYearOverviewTable();
    createPartyExtremesTable();
    createElectorateStabilityTable();
    createBoothShareChart();
    createVoteTypeChart();
    createBoothFlipsChart();
    updateHistoricalElectorateCharts();
}
// LC-specific toggle for historical view
// LC-specific toggle for historical view
function toggleLCHistoricalMode(mode) {
    if (currentElectionType !== 'lc') return;
    
    const aggregateBtn = document.getElementById('lcAggregateBtn');
    const divisionBtn = document.getElementById('lcDivisionBtn');
    const divisionSelect = document.getElementById('lcDivisionSelect');
    
    if (mode === 'aggregate') {
        aggregateBtn.classList.add('active');
        divisionBtn.classList.remove('active');
        divisionSelect.style.display = 'none';
        divisionSelect.value = ''; // Clear selection
        loadHistoricalData(); // Load all data
    } else {
        divisionBtn.classList.add('active');
        aggregateBtn.classList.remove('active');
        divisionSelect.style.display = 'inline-block';
        
        // Populate division select with LC divisions
        const divisions = new Set();
        Object.keys(ELECTION_DATA.lc).forEach(year => {
            const data = ELECTION_DATA.lc[year];
            if (data) data.forEach(d => divisions.add(d.d));
        });
        divisionSelect.innerHTML = '<option value="">Select division</option>';
        [...divisions].sort().forEach(div => {
            divisionSelect.innerHTML += `<option value="${div}">${div}</option>`;
        });
    }
}
// Update view when LC division is selected
function updateLCDivisionView() {
    const divisionSelect = document.getElementById('lcDivisionSelect');
    const selectedDivision = divisionSelect ? divisionSelect.value : '';
    
    // Update the chart title
    const chartTitle = document.getElementById('electorateWinChartTitle');
    if (chartTitle) {
        if (selectedDivision) {
            chartTitle.innerHTML = `Winning Margins Over Time
                <span class="info-icon" data-tooltip="Shows the winning margin percentage for ${selectedDivision} division across elections. Higher bars indicate more decisive victories.">?</span>`;
        } else {
            chartTitle.innerHTML = `Electorates Won by Party Over Time
                <span class="info-icon" data-tooltip="Number of LC electorates won by each party/independent in contested elections each year.">?</span>`;
        }
    }
    
    if (!selectedDivision) {
        loadHistoricalData(); // Load all data if no division selected
        return;
    }
    
    // Filter data for selected division and reload charts
    loadHistoricalDataForDivision(selectedDivision);
}

// Load historical data filtered for a specific LC division
function loadHistoricalDataForDivision(division) {
    const years = getAvailableYears();
    
    // Filter years to only those where this division contested
    const divisionYears = years.filter(year => {
        const data = ELECTION_DATA.lc[year];
        return data && data.some(d => d.d === division);
    });
    
    // Update year selectors with division-specific years
    const swingFromSelect = document.getElementById('swingFromYear');
    const swingToSelect = document.getElementById('swingToYear');
    if (swingFromSelect && swingToSelect) {
        swingFromSelect.innerHTML = '<option value="">From Year</option>';
        swingToSelect.innerHTML = '<option value="">To Year</option>';
        divisionYears.forEach(year => {
            swingFromSelect.innerHTML += `<option value="${year}">${year}</option>`;
            swingToSelect.innerHTML += `<option value="${year}">${year}</option>`;
        });
    }
    
    // Update electorate selector to show only this division
    const electorateSelect = document.getElementById('historicalElectorateSelect');
    if (electorateSelect) {
        electorateSelect.innerHTML = `<option value="${division}">${division} (Selected Division)</option>`;
        electorateSelect.value = division;
    }
    
    // Create division-specific charts
    createDivisionVoteTrendChart(division, divisionYears);
    createDivisionYearOverviewTable(division, divisionYears);
    createDivisionBoothShareChart(division, divisionYears);
    createDivisionVoteTypeChart(division, divisionYears);
    createDivisionBoothFlipsChart(division, divisionYears);
    
    // Update other charts to show only this division
    updateHistoricalElectorateCharts();
}
// Create vote trend chart for specific division
function createDivisionVoteTrendChart(division, divisionYears) {
    const ctx = document.getElementById('voteTrendChart');
    if (!ctx) return;
    
    const partyData = {};
    const partySet = new Set();

    divisionYears.forEach(year => {
        const data = ELECTION_DATA.lc[year];
        if (!data) return;
        const divData = data.filter(d => d.d === division);
        divData.forEach(row => {
            const party = normalizeParty(row.p);
            if (party !== 'INF') partySet.add(party);
        });
    });

    const parties = Array.from(partySet).sort();
    parties.forEach(party => { partyData[party] = []; });

    divisionYears.forEach(year => {
        const data = ELECTION_DATA.lc[year];
        if (!data) return;
        
        const divData = data.filter(d => d.d === division);
        const partyVotes = {};
        let totalVotes = 0;

        divData.forEach(row => {
            const party = normalizeParty(row.p);
            if (party !== 'INF') {
                if (!partyVotes[party]) partyVotes[party] = 0;
                partyVotes[party] += row.v;
                totalVotes += row.v;
            }
        });

        parties.forEach(party => {
            const votes = partyVotes[party] || 0;
            const percentage = totalVotes > 0 ? (votes / totalVotes * 100) : 0;
            partyData[party].push(percentage);
        });
    });

    const maxPercentage = Math.max(...parties.map(p => Math.max(...partyData[p])));
    const yMax = maxPercentage < 60 ? 60 : 100;

    if (charts.voteTrend) charts.voteTrend.destroy();

    charts.voteTrend = new Chart(ctx.getContext('2d'), {
        type: 'line',
        data: {
            labels: divisionYears,
            datasets: parties.map(party => ({
                label: getPartyName(party),
                data: partyData[party],
                borderColor: getPartyColor(party),
                backgroundColor: getPartyColor(party) + '20',
                tension: 0.2
            }))
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: `${division} Division - Vote Share Over Time`
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: yMax,
                    ticks: { callback: value => value + '%' }
                }
            }
        }
    });
}

// Create year overview table for specific division
function createDivisionYearOverviewTable(division, divisionYears) {
    const tbody = document.getElementById('yearOverviewBody');
    if (!tbody) return;
    
    tbody.innerHTML = '';
    
    divisionYears.forEach(year => {
        const data = ELECTION_DATA.lc[year];
        if (!data) return;
        
        const divData = data.filter(d => d.d === division);
        const partyVotes = {};
        let totalVotes = 0;
        let nonPhysicalVotes = 0;
        
        divData.forEach(row => {
            const party = normalizeParty(row.p);
            if (party !== 'INF') {
                if (!partyVotes[party]) partyVotes[party] = 0;
                partyVotes[party] += row.v;
                totalVotes += row.v;
                
                // Calculate non-physical votes
                if (row.b && Array.isArray(row.b)) {
                    row.b.forEach(booth => {
                        if (!isPhysicalBooth(booth.n)) {
                            nonPhysicalVotes += booth.v;
                        }
                    });
                }
            }
        });
        
        // Find winner
        let winner = null;
        let maxVotes = 0;
        divData.forEach(row => {
            if (row.v > maxVotes) {
                maxVotes = row.v;
                winner = normalizeParty(row.p);
            }
        });
        
        // Calculate ENP
        const shares = Object.values(partyVotes).map(v => v / totalVotes);
        const enp = 1 / shares.reduce((sum, s) => sum + s * s, 0);
        
        const row = tbody.insertRow();
        row.innerHTML = `
            <td>${year}</td>
            <td>1</td>
            <td>${totalVotes.toLocaleString()}</td>
            <td>${((partyVotes['ALP'] || 0) / totalVotes * 100).toFixed(1)}%</td>
            <td>${((partyVotes['LIB'] || 0) / totalVotes * 100).toFixed(1)}%</td>
            <td>${((partyVotes['GRN'] || 0) / totalVotes * 100).toFixed(1)}%</td>
            <td>${((partyVotes['IND'] || 0) / totalVotes * 100).toFixed(1)}%</td>
            <td>${winner ? getPartyName(winner) : 'N/A'}</td>
            <td>${enp.toFixed(2)}</td>
            <td>${(nonPhysicalVotes / totalVotes * 100).toFixed(1)}%</td>
        `;
    });
}

// Create booth share chart for specific division
function createDivisionBoothShareChart(division, divisionYears) {
    const ctx = document.getElementById('boothShareChart');
    if (!ctx) return;
    
    const partyData = {};
    const partySet = new Set();

    divisionYears.forEach(year => {
        const boothWinners = calculateBoothWinners(year, division);
        boothWinners.forEach(booth => {
            const party = normalizeParty(booth.party);
            partySet.add(party);
        });
    });

    const parties = Array.from(partySet).sort();
    parties.forEach(party => { partyData[party] = []; });

    divisionYears.forEach(year => {
        const boothWinners = calculateBoothWinners(year, division);
        const totalBooths = boothWinners.length;

        const partyBooths = {};
        parties.forEach(p => partyBooths[p] = 0);

        boothWinners.forEach(booth => {
            const party = normalizeParty(booth.party);
            if (partyBooths[party] !== undefined) {
                partyBooths[party]++;
            }
        });

        parties.forEach(party => {
            const percentage = totalBooths > 0 ? (partyBooths[party] / totalBooths * 100) : 0;
            partyData[party].push(percentage);
        });
    });

    const maxPercentage = Math.max(...parties.map(p => Math.max(...partyData[p])));
    const yMax = maxPercentage < 60 ? 60 : 100;

    if (charts.boothShare) charts.boothShare.destroy();

    charts.boothShare = new Chart(ctx.getContext('2d'), {
        type: 'line',
        data: {
            labels: divisionYears,
            datasets: parties.map(party => ({
                label: getPartyName(party),
                data: partyData[party],
                borderColor: getPartyColor(party),
                backgroundColor: getPartyColor(party) + '20',
                tension: 0.2,
                fill: false
            }))
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: `${division} Division - Booth Winners Over Time`
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: yMax,
                    ticks: { callback: value => value + '%' }
                }
            }
        }
    });
}

// Create vote type chart for specific division
function createDivisionVoteTypeChart(division, divisionYears) {
    const ctx = document.getElementById('voteTypeChart');
    if (!ctx) return;
    
    const physicalData = [];
    const nonPhysicalData = [];
    
    divisionYears.forEach(year => {
        const data = ELECTION_DATA.lc[year];
        if (!data) return;
        
        const divData = data.filter(d => d.d === division);
        let physicalVotes = 0;
        let nonPhysicalVotes = 0;
        
        divData.forEach(row => {
            if (row.b && Array.isArray(row.b)) {
                row.b.forEach(booth => {
                    if (isPhysicalBooth(booth.n)) {
                        physicalVotes += booth.v;
                    } else {
                        nonPhysicalVotes += booth.v;
                    }
                });
            }
        });
        
        const total = physicalVotes + nonPhysicalVotes;
        physicalData.push(total > 0 ? (physicalVotes / total * 100) : 0);
        nonPhysicalData.push(total > 0 ? (nonPhysicalVotes / total * 100) : 0);
    });

    const maxPercentage = Math.max(...physicalData, ...nonPhysicalData);
    const yMax = maxPercentage < 60 ? 60 : 100;

    if (charts.voteType) charts.voteType.destroy();

    charts.voteType = new Chart(ctx.getContext('2d'), {
        type: 'line',
        data: {
            labels: divisionYears,
            datasets: [
                {
                    label: 'Physical Booths',
                    data: physicalData,
                    borderColor: '#4A5A6A',
                    backgroundColor: '#4A5A6A20',
                    tension: 0.2
                },
                {
                    label: 'Non-Physical (Postal, Pre-poll, etc.)',
                    data: nonPhysicalData,
                    borderColor: '#C5A572',
                    backgroundColor: '#C5A57220',
                    tension: 0.2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' },
                title: {
                    display: true,
                    text: `${division} Division - Vote Type Distribution`
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: yMax,
                    ticks: { callback: value => value + '%' }
                }
            }
        }
    });
}

// Create booth flips chart for specific division
function createDivisionBoothFlipsChart(division, divisionYears) {
    const ctx = document.getElementById('boothFlipsChart');
    const tbody = document.getElementById('boothFlipsTableBody');
    if (!ctx || !tbody) return;
    
    const flipsData = [];
    const partySet = new Set();
    
    // Compare consecutive contests for this division
    for (let i = 1; i < divisionYears.length; i++) {
        const prevYear = divisionYears[i - 1];
        const currYear = divisionYears[i];
        const transition = `${prevYear}→${currYear}`;
        
        const shifts = computeBoothRankShifts(currYear, prevYear, division);
        
        // Count flips by destination party
        const flipsByParty = {};
        shifts.topChanges.forEach(change => {
            const toParty = normalizeParty(change.currTop);
            partySet.add(toParty);
            if (!flipsByParty[toParty]) flipsByParty[toParty] = 0;
            flipsByParty[toParty]++;
        });
        
        flipsData.push({
            transition,
            total: shifts.topChanges.length,
            byParty: flipsByParty
        });
    }
    
    // Create stacked bar chart
    const parties = Array.from(partySet).sort();
    const datasets = parties.map(party => ({
        label: getPartyName(party),
        data: flipsData.map(d => d.byParty[party] || 0),
        backgroundColor: getPartyColor(party)
    }));
    
    if (charts.boothFlips) charts.boothFlips.destroy();
    
    charts.boothFlips = new Chart(ctx.getContext('2d'), {
        type: 'bar',
        data: {
            labels: flipsData.map(d => d.transition),
            datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: `${division} Division - Booth Flips Between Elections`
                }
            },
            scales: {
                x: { stacked: true },
                y: { 
                    stacked: true,
                    beginAtZero: true,
                    ticks: { precision: 0 }
                }
            }
        }
    });
    
    // Update table
    tbody.innerHTML = '';
    flipsData.forEach(data => {
        const row = tbody.insertRow();
        row.innerHTML = `
            <td>${data.transition}</td>
            <td>${data.total}</td>
            <td>${data.byParty['ALP'] || 0}</td>
            <td>${data.byParty['LIB'] || 0}</td>
            <td>${data.byParty['GRN'] || 0}</td>
            <td>${data.byParty['IND'] || 0}</td>
        `;
    });
}

function createLCElectorateWinTrendChart() {
    const ctx = document.getElementById('electorateWinChart');
    if (!ctx) return;
    
    // Check if we're in division mode
    const divisionSelect = document.getElementById('lcDivisionSelect');
    const selectedDivision = divisionSelect && divisionSelect.style.display !== 'none' ? divisionSelect.value : '';
    
    if (selectedDivision) {
        // For single division: Show margin of victory over time
        const years = getAvailableYears();
        const divisionYears = years.filter(year => {
            const data = ELECTION_DATA.lc[year];
            return data && data.some(d => d.d === selectedDivision);
        });
        
        const marginData = [];
        const winnerColors = [];
        const winnerLabels = [];
        
        divisionYears.forEach(year => {
            const data = ELECTION_DATA.lc[year];
            if (!data) return;
            
            const divData = data.filter(d => d.d === selectedDivision);
            const sorted = divData.sort((a, b) => b.v - a.v);
            const winner = sorted[0];
            const runnerUp = sorted[1];
            
            if (winner) {
                const totalVotes = divData.reduce((sum, c) => sum + c.v, 0);
                let margin = 0;
                
                if (runnerUp) {
                    // Calculate TCP margin
                    margin = ((winner.v - runnerUp.v) / totalVotes * 100);
                } else {
                    // Unopposed
                    margin = 100;
                }
                
                marginData.push(margin);
                winnerColors.push(getPartyColor(normalizeParty(winner.p)));
                winnerLabels.push(`${winner.c} (${getPartyName(normalizeParty(winner.p))})`);
            }
        });
        
        if (charts.electorateWin) charts.electorateWin.destroy();
        
        // Create margin chart for single division
        charts.electorateWin = new Chart(ctx.getContext('2d'), {
            type: 'bar',
            data: {
                labels: divisionYears,
                datasets: [{
                    label: 'Winning Margin %',
                    data: marginData,
                    backgroundColor: winnerColors,
                    borderColor: winnerColors,
                    borderWidth: 2
                }]
            },
            options: {
                responsive: true,
                maintainAspectRatio: false,
                plugins: {
                    legend: { display: false },
                    title: {
                        display: true,
                        text: `${selectedDivision} Division - Winning Margins Over Time`
                    },
                    tooltip: {
                        callbacks: {
                            label: function(context) {
                                const label = winnerLabels[context.dataIndex];
                                const margin = marginData[context.dataIndex];
                                return [`Winner: ${label}`, `Margin: ${margin.toFixed(1)}%`];
                            }
                        }
                    }
                },
                scales: {
                    y: {
                        beginAtZero: true,
                        max: 100,
                        ticks: {
                            callback: value => value + '%'
                        },
                        title: {
                            display: true,
                            text: 'Winning Margin (%)'
                        }
                    },
                    x: {
                        title: {
                            display: true,
                            text: 'Election Year'
                        }
                    }
                }
            }
        });
        
        return;
    }
    
    // AGGREGATE VIEW - Original code for showing electorates won by party
    const years = getAvailableYears();
    const partyWins = {};
    const partySet = new Set();
    
    years.forEach(year => {
        const data = ELECTION_DATA.lc[year];
        if (!data) return;
        
        // Group by electorate to find winners
        const electorates = new Set(data.map(d => d.d));
        electorates.forEach(elec => {
            const elecData = data.filter(d => d.d === elec);
            const winner = elecData.sort((a, b) => b.v - a.v)[0];
            if (winner) {
                const party = normalizeParty(winner.p);
                partySet.add(party);
            }
        });
    });
    
    const parties = Array.from(partySet).sort();
    parties.forEach(party => { partyWins[party] = []; });
    
    years.forEach(year => {
        const data = ELECTION_DATA.lc[year];
        if (!data) return;
        
        const yearWins = {};
        parties.forEach(p => yearWins[p] = 0);
        
        const electorates = new Set(data.map(d => d.d));
        electorates.forEach(elec => {
            const elecData = data.filter(d => d.d === elec);
            const winner = elecData.sort((a, b) => b.v - a.v)[0];
            if (winner) {
                const party = normalizeParty(winner.p);
                yearWins[party] = (yearWins[party] || 0) + 1;
            }
        });
        
        parties.forEach(party => {
            partyWins[party].push(yearWins[party] || 0);
        });
    });
    
    if (charts.electorateWin) charts.electorateWin.destroy();
    
    charts.electorateWin = new Chart(ctx.getContext('2d'), {
        type: 'line',
        data: {
            labels: years,
            datasets: parties.map(party => ({
                label: getPartyName(party),
                data: partyWins[party],
                borderColor: getPartyColor(party),
                backgroundColor: getPartyColor(party) + '20',
                tension: 0.2
            }))
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: 'Electorates Won by Party Over Time'
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: { precision: 0 },
                    title: {
                        display: true,
                        text: 'Number of Electorates Won'
                    }
                }
            }
        }
    });
}

function createVoteTrendChart() {
    const ctx = document.getElementById('voteTrendChart');
    if (!ctx) return;
    
    const years = getAvailableYears();
    const partyData = {};
    const partySet = new Set();

    years.forEach(year => {
        const data = currentElectionType === 'state'
            ? ELECTION_DATA.state[year]
            : ELECTION_DATA.lc[year];
        if (!data) return;
        data.forEach(row => {
            const party = normalizeParty(row.p);
            if (party !== 'INF') partySet.add(party);
        });
    });

    const parties = Array.from(partySet).sort();
    parties.forEach(party => { partyData[party] = []; });

    years.forEach(year => {
        const data = currentElectionType === 'state'
            ? ELECTION_DATA.state[year]
            : ELECTION_DATA.lc[year];

        if (!data) return;

        const partyVotes = {};
        let totalVotes = 0;

        data.forEach(row => {
            const party = normalizeParty(row.p);
            if (party !== 'INF') {
                if (!partyVotes[party]) partyVotes[party] = 0;
                partyVotes[party] += row.v;
                totalVotes += row.v;
            }
        });

        parties.forEach(party => {
            const votes = partyVotes[party] || 0;
            const percentage = totalVotes > 0 ? (votes / totalVotes * 100) : 0;
            partyData[party].push(percentage);
        });
    });

    const maxPercentage = Math.max(...parties.map(p => Math.max(...partyData[p])));
    const yMax = maxPercentage < 60 ? 60 : 100;

    if (charts.voteTrend) charts.voteTrend.destroy();

    charts.voteTrend = new Chart(ctx.getContext('2d'), {
        type: 'line',
        data: {
            labels: years,
            datasets: parties.map(party => ({
                label: getPartyName(party),
                data: partyData[party],
                borderColor: getPartyColor(party),
                backgroundColor: getPartyColor(party) + '20',
                tension: 0.2
            }))
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: yMax,
                    ticks: { callback: value => value + '%' }
                }
            }
        }
    });
}

function createSeatTrendChart() {
    const ctx = document.getElementById('seatTrendChart');
    if (!ctx) return;
    
    const years = getAvailableYears();
    const partySeats = {};
    const partySet = new Set();

    years.forEach(year => {
        const seatData = SEAT_RESULTS.state[year] || [];
        seatData.forEach(result => {
            const party = normalizeParty(result.party);
            partySet.add(party);
        });
    });

    const parties = Array.from(partySet).sort();
    parties.forEach(party => { partySeats[party] = []; });

    years.forEach(year => {
        const seatData = SEAT_RESULTS.state[year] || [];
        const yearSeats = {};

        seatData.forEach(result => {
            const party = normalizeParty(result.party);
            if (!yearSeats[party]) yearSeats[party] = 0;
            yearSeats[party] += result.seats_won;
        });

        parties.forEach(party => {
            partySeats[party].push(yearSeats[party] || 0);
        });
    });
    
    if (charts.seatTrend) charts.seatTrend.destroy();
    
    charts.seatTrend = new Chart(ctx.getContext('2d'), {
        type: 'line',
        data: {
            labels: years,
            datasets: parties.map(party => ({
                label: getPartyName(party),
                data: partySeats[party],
                borderColor: getPartyColor(party),
                backgroundColor: getPartyColor(party) + '20',
                tension: 0.2
            }))
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    ticks: { precision: 0 }
                }
            }
        }
    });
}

function createYearOverviewTable() {
    const tbody = document.getElementById('yearOverviewBody');
    if (!tbody) return;
    
    const years = getAvailableYears();
    tbody.innerHTML = '';
    
    years.forEach(year => {
        const data = currentElectionType === 'state' 
            ? ELECTION_DATA.state[year] 
            : ELECTION_DATA.lc[year];
        
        if (!data) return;
        
        const partyVotes = {};
        let totalVotes = 0;
        let nonPhysicalVotes = 0;
        
        // For LC, count contested electorates
        const contestedElectorates = currentElectionType === 'lc' 
            ? new Set(data.map(d => d.d)).size 
            : null;
        
        // Count electorate winners for LC
        const electorateWinners = {};
        if (currentElectionType === 'lc') {
            const electorates = new Set(data.map(d => d.d));
            electorates.forEach(elec => {
                const elecData = data.filter(d => d.d === elec);
                const winner = elecData.sort((a, b) => b.v - a.v)[0];
                if (winner) {
                    const party = normalizeParty(winner.p);
                    electorateWinners[party] = (electorateWinners[party] || 0) + 1;
                }
            });
        }
        
        data.forEach(row => {
            const party = normalizeParty(row.p);
            if (party !== 'INF') {
                if (!partyVotes[party]) partyVotes[party] = 0;
                partyVotes[party] += row.v;
                totalVotes += row.v;
                
                // Calculate non-physical votes
                if (row.b && Array.isArray(row.b)) {
                    row.b.forEach(booth => {
                        if (!isPhysicalBooth(booth.n)) {
                            nonPhysicalVotes += booth.v;
                        }
                    });
                }
            }
        });
        
        // Calculate ENP (Effective Number of Parties)
        const shares = Object.values(partyVotes).map(v => v / totalVotes);
        const enp = 1 / shares.reduce((sum, s) => sum + s * s, 0);
        
        // Get seat count for state elections or electorate count for LC
        let seatsOrElectorates = 0;
        if (currentElectionType === 'state') {
            const seatData = SEAT_RESULTS.state[year] || [];
            seatsOrElectorates = seatData.reduce((sum, r) => sum + r.seats_won, 0);
        } else {
            seatsOrElectorates = Object.values(electorateWinners).reduce((sum, v) => sum + v, 0);
        }
        
        const row = tbody.insertRow();
        row.innerHTML = `
            <td>${year}</td>
            ${currentElectionType === 'lc' ? `<td>${contestedElectorates}</td>` : ''}
            <td>${totalVotes.toLocaleString()}</td>
            <td>${((partyVotes['ALP'] || 0) / totalVotes * 100).toFixed(1)}%</td>
            <td>${((partyVotes['LIB'] || 0) / totalVotes * 100).toFixed(1)}%</td>
            <td>${((partyVotes['GRN'] || 0) / totalVotes * 100).toFixed(1)}%</td>
            <td>${((partyVotes['IND'] || 0) / totalVotes * 100).toFixed(1)}%</td>
            <td>${seatsOrElectorates}</td>
            <td>${enp.toFixed(2)}</td>
            <td>${(nonPhysicalVotes / totalVotes * 100).toFixed(1)}%</td>
        `;
    });
}

function createPartyExtremesTable() {
    const bestBody = document.getElementById('partyBestBody');
    const worstBody = document.getElementById('partyWorstBody');
    if (!bestBody || !worstBody) return;
    
    const years = getAvailableYears();
    const parties = ['ALP', 'LIB', 'GRN', 'IND'];
    const partyPerformances = {};
    
    parties.forEach(party => {
        partyPerformances[party] = [];
    });
    
    years.forEach(year => {
        const data = currentElectionType === 'state' 
            ? ELECTION_DATA.state[year] 
            : ELECTION_DATA.lc[year];
        
        if (!data) return;
        
        const partyVotes = {};
        let totalVotes = 0;
        
        data.forEach(row => {
            const party = normalizeParty(row.p);
            if (party !== 'INF') {
                if (!partyVotes[party]) partyVotes[party] = 0;
                partyVotes[party] += row.v;
                totalVotes += row.v;
            }
        });
        
        parties.forEach(party => {
            const percentage = totalVotes > 0 ? (partyVotes[party] || 0) / totalVotes * 100 : 0;
            partyPerformances[party].push({ year, percentage });
        });
    });
    
    bestBody.innerHTML = '';
    worstBody.innerHTML = '';
    
    parties.forEach(party => {
        const performances = partyPerformances[party];
        if (performances.length === 0) return;
        
        const sorted = [...performances].sort((a, b) => b.percentage - a.percentage);
        const best = sorted[0];
        const worst = sorted[sorted.length - 1];
        
        const bestRow = bestBody.insertRow();
        bestRow.innerHTML = `
            <td><span class="party-badge" style="background: ${getPartyColor(party)}">${getPartyName(party)}</span></td>
            <td>${best.percentage.toFixed(1)}%</td>
            <td>${best.year}</td>
        `;
        
        const worstRow = worstBody.insertRow();
        worstRow.innerHTML = `
            <td><span class="party-badge" style="background: ${getPartyColor(party)}">${getPartyName(party)}</span></td>
            <td>${worst.percentage.toFixed(1)}%</td>
            <td>${worst.year}</td>
        `;
    });
}

function createElectorateStabilityTable() {
    const tbody = document.getElementById('electorateStabilityBody');
    if (!tbody) return;
    
    const years = getAvailableYears();
    const electorateData = {};
    
    years.forEach(year => {
        const data = currentElectionType === 'state' 
            ? ELECTION_DATA.state[year] 
            : ELECTION_DATA.lc[year];
        
        if (!data) return;
        
        const electorates = {};
        data.forEach(row => {
            const party = normalizeParty(row.p);
            if (party !== 'INF') {
                if (!electorates[row.d]) {
                    electorates[row.d] = {};
                }
                if (!electorates[row.d][party]) {
                    electorates[row.d][party] = 0;
                }
                electorates[row.d][party] += row.v;
            }
        });
        
        Object.entries(electorates).forEach(([elec, partyVotes]) => {
            if (!electorateData[elec]) {
                electorateData[elec] = [];
            }
            const total = Object.values(partyVotes).reduce((sum, v) => sum + v, 0);
            const shares = {};
            Object.entries(partyVotes).forEach(([party, votes]) => {
                shares[party] = (votes / total * 100);
            });
            electorateData[elec].push({ year, shares });
        });
    });
    
    // Calculate volatility for each electorate
    const volatilityData = [];
    Object.entries(electorateData).forEach(([elec, yearData]) => {
        if (yearData.length < 2) return;
        
        let totalSwing = 0;
        let swingCount = 0;
        
        // For LC, only compare consecutive contests for the same electorate
        if (currentElectionType === 'lc') {
            for (let i = 1; i < yearData.length; i++) {
                const prev = yearData[i - 1].shares;
                const curr = yearData[i].shares;
                const parties = new Set([...Object.keys(prev), ...Object.keys(curr)]);
                
                parties.forEach(party => {
                    const prevShare = prev[party] || 0;
                    const currShare = curr[party] || 0;
                    totalSwing += Math.abs(currShare - prevShare);
                    swingCount++;
                });
            }
        } else {
            for (let i = 1; i < yearData.length; i++) {
                const prev = yearData[i - 1].shares;
                const curr = yearData[i].shares;
                const parties = new Set([...Object.keys(prev), ...Object.keys(curr)]);
                
                parties.forEach(party => {
                    const prevShare = prev[party] || 0;
                    const currShare = curr[party] || 0;
                    totalSwing += Math.abs(currShare - prevShare);
                    swingCount++;
                });
            }
        }
        
        const avgVolatility = swingCount > 0 ? totalSwing / swingCount : 0;
        
        // Find leading party (most recent year)
        const latest = yearData[yearData.length - 1].shares;
        let leadingParty = '';
        let maxShare = 0;
        Object.entries(latest).forEach(([party, share]) => {
            if (share > maxShare) {
                maxShare = share;
                leadingParty = party;
            }
        });
        
        volatilityData.push({
            electorate: elec,
            volatility: avgVolatility,
            leadingParty,
            trend: yearData
        });
    });
    
    // Sort by volatility
    volatilityData.sort((a, b) => b.volatility - a.volatility);
    
    tbody.innerHTML = '';
    volatilityData.slice(0, 10).forEach(data => {
        const row = tbody.insertRow();
        const volatilityClass = data.volatility > 5 ? 'color: red' : data.volatility > 3 ? 'color: orange' : 'color: green';
        row.innerHTML = `
            <td>${data.electorate}</td>
            <td style="${volatilityClass}">${data.volatility.toFixed(2)}</td>
            <td><span class="party-badge" style="background: ${getPartyColor(data.leadingParty)}">${getPartyName(data.leadingParty)}</span></td>
            <td>Work in progress *W Manning*</td>
        `;
    });
}

function updateHistoricalElectorateCharts() {
    const electorate = document.getElementById('historicalElectorateSelect').value;
    const ctx = document.getElementById('electorateVoteTrendChart');
    if (!ctx) return;
    
    const years = getAvailableYears();
    const partyData = {};
    const partySet = new Set();

    // For LC, if an electorate is selected, only show years it contested
    let relevantYears = years;
    if (currentElectionType === 'lc' && electorate) {
        relevantYears = years.filter(year => {
            const data = ELECTION_DATA.lc[year];
            return data && data.some(d => d.d === electorate);
        });
    }

    relevantYears.forEach(year => {
        const data = currentElectionType === 'state'
            ? ELECTION_DATA.state[year]
            : ELECTION_DATA.lc[year];

        if (!data) return;

        const filteredData = electorate
            ? data.filter(d => d.d === electorate)
            : data;

        filteredData.forEach(row => {
            const party = normalizeParty(row.p);
            if (party !== 'INF') partySet.add(party);
        });
    });

    const parties = Array.from(partySet).sort();
    parties.forEach(party => { partyData[party] = []; });

    relevantYears.forEach(year => {
        const data = currentElectionType === 'state'
            ? ELECTION_DATA.state[year]
            : ELECTION_DATA.lc[year];

        if (!data) return;

        const filteredData = electorate
            ? data.filter(d => d.d === electorate)
            : data;

        const partyVotes = {};
        let totalVotes = 0;

        filteredData.forEach(row => {
            const party = normalizeParty(row.p);
            if (party !== 'INF') {
                if (!partyVotes[party]) partyVotes[party] = 0;
                partyVotes[party] += row.v;
                totalVotes += row.v;
            }
        });

        parties.forEach(party => {
            const votes = partyVotes[party] || 0;
            const percentage = totalVotes > 0 ? (votes / totalVotes * 100) : 0;
            partyData[party].push(percentage);
        });
    });

    const maxPercentage = Math.max(...parties.map(p => Math.max(...partyData[p])));
    const yMax = maxPercentage < 60 ? 60 : 100;

    if (charts.electorateVoteTrend) charts.electorateVoteTrend.destroy();

    charts.electorateVoteTrend = new Chart(ctx.getContext('2d'), {
        type: 'line',
        data: {
            labels: relevantYears,
            datasets: parties.map(party => ({
                label: getPartyName(party),
                data: partyData[party],
                borderColor: getPartyColor(party),
                backgroundColor: getPartyColor(party) + '20',
                tension: 0.2
            }))
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false },
                title: {
                    display: true,
                    text: electorate || 'All Electorates'
                }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: yMax,
                    ticks: { callback: value => value + '%' }
                }
            }
        }
    });
}

function updateSwingAnalysis() {
    const fromYear = parseInt(document.getElementById('swingFromYear').value);
    const toYear = parseInt(document.getElementById('swingToYear').value);
    const party = document.getElementById('swingParty').value;
    
    if (!fromYear || !toYear || fromYear >= toYear) {
        document.getElementById('topSwingsBody').innerHTML = '<tr><td colspan="3">Select valid year range</td></tr>';
        document.getElementById('bottomSwingsBody').innerHTML = '<tr><td colspan="3">Select valid year range</td></tr>';
        return;
    }
    
    const fromData = currentElectionType === 'state' 
        ? ELECTION_DATA.state[fromYear] 
        : ELECTION_DATA.lc[fromYear];
    const toData = currentElectionType === 'state' 
        ? ELECTION_DATA.state[toYear] 
        : ELECTION_DATA.lc[toYear];
    
    if (!fromData || !toData) return;
    
    // Calculate swings by electorate
    const electorateSwings = [];
    const electorates = new Set();
    
    // For LC, only compare electorates that contested in both years
    if (currentElectionType === 'lc') {
        const fromElectorates = new Set(fromData.map(d => d.d));
        const toElectorates = new Set(toData.map(d => d.d));
        fromElectorates.forEach(elec => {
            if (toElectorates.has(elec)) {
                electorates.add(elec);
            }
        });
    } else {
        fromData.forEach(d => electorates.add(d.d));
        toData.forEach(d => electorates.add(d.d));
    }
    
    electorates.forEach(elec => {
        const fromElecData = fromData.filter(d => d.d === elec);
        const toElecData = toData.filter(d => d.d === elec);
        
        if (fromElecData.length === 0 || toElecData.length === 0) return;
        
        // Calculate party shares for both years
        const fromVotes = {};
        let fromTotal = 0;
        fromElecData.forEach(row => {
            const p = normalizeParty(row.p);
            if (p !== 'INF') {
                if (!fromVotes[p]) fromVotes[p] = 0;
                fromVotes[p] += row.v;
                fromTotal += row.v;
            }
        });
        
        const toVotes = {};
        let toTotal = 0;
        toElecData.forEach(row => {
            const p = normalizeParty(row.p);
            if (p !== 'INF') {
                if (!toVotes[p]) toVotes[p] = 0;
                toVotes[p] += row.v;
                toTotal += row.v;
            }
        });
        
        const fromShare = fromTotal > 0 ? (fromVotes[party] || 0) / fromTotal * 100 : 0;
        const toShare = toTotal > 0 ? (toVotes[party] || 0) / toTotal * 100 : 0;
        const swing = toShare - fromShare;
        
        electorateSwings.push({
            electorate: elec,
            swing,
            finalShare: toShare
        });
    });
    
    // Sort and display
    electorateSwings.sort((a, b) => b.swing - a.swing);
    
    const topBody = document.getElementById('topSwingsBody');
    const bottomBody = document.getElementById('bottomSwingsBody');
    
    topBody.innerHTML = '';
    electorateSwings.slice(0, 10).forEach(data => {
        const row = topBody.insertRow();
        row.innerHTML = `
            <td>${data.electorate}</td>
            <td style="color: green">+${data.swing.toFixed(2)}pp</td>
            <td>${data.finalShare.toFixed(1)}%</td>
        `;
    });
    
    bottomBody.innerHTML = '';
    electorateSwings.slice(-10).reverse().forEach(data => {
        const row = bottomBody.insertRow();
        row.innerHTML = `
            <td>${data.electorate}</td>
            <td style="color: red">${data.swing.toFixed(2)}pp</td>
            <td>${data.finalShare.toFixed(1)}%</td>
        `;
    });
}

function createBoothShareChart() {
    const ctx = document.getElementById('boothShareChart');
    if (!ctx) return;
    
    const years = getAvailableYears();
    const partyData = {};
    const partySet = new Set();

    years.forEach(year => {
        const boothWinners = calculateBoothWinners(year, '');
        boothWinners.forEach(booth => {
            const party = normalizeParty(booth.party);
            partySet.add(party);
        });
    });

    const parties = Array.from(partySet).sort();
    parties.forEach(party => { partyData[party] = []; });

    years.forEach(year => {
        const boothWinners = calculateBoothWinners(year, '');
        const totalBooths = boothWinners.length;

        const partyBooths = {};
        parties.forEach(p => partyBooths[p] = 0);

        boothWinners.forEach(booth => {
            const party = normalizeParty(booth.party);
            if (partyBooths[party] !== undefined) {
                partyBooths[party]++;
            }
        });

        parties.forEach(party => {
            const percentage = totalBooths > 0 ? (partyBooths[party] / totalBooths * 100) : 0;
            partyData[party].push(percentage);
        });
    });

    const maxPercentage = Math.max(...parties.map(p => Math.max(...partyData[p])));
    const yMax = maxPercentage < 60 ? 60 : 100;

    if (charts.boothShare) charts.boothShare.destroy();

    charts.boothShare = new Chart(ctx.getContext('2d'), {
        type: 'line',
        data: {
            labels: years,
            datasets: parties.map(party => ({
                label: getPartyName(party),
                data: partyData[party],
                borderColor: getPartyColor(party),
                backgroundColor: getPartyColor(party) + '20',
                tension: 0.2,
                fill: false
            }))
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: yMax,
                    ticks: { callback: value => value + '%' }
                }
            }
        }
    });
}

function createVoteTypeChart() {
    const ctx = document.getElementById('voteTypeChart');
    if (!ctx) return;
    
    const years = getAvailableYears();
    const physicalData = [];
    const nonPhysicalData = [];
    
    years.forEach(year => {
        const data = currentElectionType === 'state' 
            ? ELECTION_DATA.state[year] 
            : ELECTION_DATA.lc[year];
        
        if (!data) return;
        
        let physicalVotes = 0;
        let nonPhysicalVotes = 0;
        
        data.forEach(row => {
            if (row.b && Array.isArray(row.b)) {
                row.b.forEach(booth => {
                    if (isPhysicalBooth(booth.n)) {
                        physicalVotes += booth.v;
                    } else {
                        nonPhysicalVotes += booth.v;
                    }
                });
            }
        });
        
        const total = physicalVotes + nonPhysicalVotes;
        physicalData.push(total > 0 ? (physicalVotes / total * 100) : 0);
       nonPhysicalData.push(total > 0 ? (nonPhysicalVotes / total * 100) : 0);
    });

    const maxPercentage = Math.max(...physicalData, ...nonPhysicalData);
    const yMax = maxPercentage < 60 ? 60 : 100;

    if (charts.voteType) charts.voteType.destroy();

    charts.voteType = new Chart(ctx.getContext('2d'), {
        type: 'line',
        data: {
            labels: years,
            datasets: [
                {
                    label: 'Physical Booths',
                    data: physicalData,
                    borderColor: '#4A5A6A',
                    backgroundColor: '#4A5A6A20',
                    tension: 0.2
                },
                {
                    label: 'Non-Physical (Postal, Pre-poll, etc.)',
                    data: nonPhysicalData,
                    borderColor: '#C5A572',
                    backgroundColor: '#C5A57220',
                    tension: 0.2
                }
            ]
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { position: 'bottom' }
            },
            scales: {
                y: {
                    beginAtZero: true,
                    max: yMax,
                    ticks: { callback: value => value + '%' }
                }
            }
        }
    });
}

function createBoothFlipsChart() {
    const ctx = document.getElementById('boothFlipsChart');
    const tbody = document.getElementById('boothFlipsTableBody');
    if (!ctx || !tbody) return;
    
    const years = getAvailableYears();
    const transitions = [];
    const flipsData = [];
    const partySet = new Set();
    
    // For LC, handle differently
    if (currentElectionType === 'lc') {
        // Build a map of electorate -> years it contested
        const electorateYears = {};
        years.forEach(year => {
            const data = ELECTION_DATA.lc[year];
            if (data) {
                data.forEach(d => {
                    if (!electorateYears[d.d]) electorateYears[d.d] = [];
                    if (!electorateYears[d.d].includes(year)) {
                        electorateYears[d.d].push(year);
                    }
                });
            }
        });
        
        // For each electorate, compare consecutive contests
        Object.entries(electorateYears).forEach(([elec, elecYears]) => {
            elecYears.sort((a, b) => a - b);
            for (let i = 1; i < elecYears.length; i++) {
                const prevYear = elecYears[i - 1];
                const currYear = elecYears[i];
                const transition = `${elec} ${prevYear}→${currYear}`;
                
                const shifts = computeBoothRankShifts(currYear, prevYear, elec);
                
                // Count flips by destination party
                const flipsByParty = {};
                shifts.topChanges.forEach(change => {
                    const toParty = normalizeParty(change.currTop);
                    partySet.add(toParty);
                    if (!flipsByParty[toParty]) flipsByParty[toParty] = 0;
                    flipsByParty[toParty]++;
                });
                
                if (shifts.topChanges.length > 0) {
                    flipsData.push({
                        transition,
                        total: shifts.topChanges.length,
                        byParty: flipsByParty
                    });
                }
            }
        });
    } else {
        for (let i = 1; i < years.length; i++) {
            const prevYear = years[i - 1];
            const currYear = years[i];
            const transition = `${prevYear}→${currYear}`;
            transitions.push(transition);
            
            const shifts = computeBoothRankShifts(currYear, prevYear, '');
            
            // Count flips by destination party
            const flipsByParty = {};
            shifts.topChanges.forEach(change => {
                const toParty = normalizeParty(change.currTop);
                partySet.add(toParty);
                if (!flipsByParty[toParty]) flipsByParty[toParty] = 0;
                flipsByParty[toParty]++;
            });
            
            flipsData.push({
                transition,
                total: shifts.topChanges.length,
                byParty: flipsByParty
            });
        }
    }
    
    // Create stacked bar chart
    const parties = Array.from(partySet).sort();
    const datasets = parties.map(party => ({
        label: getPartyName(party),
        data: flipsData.map(d => d.byParty[party] || 0),
        backgroundColor: getPartyColor(party)
    }));
    
    if (charts.boothFlips) charts.boothFlips.destroy();
    
    charts.boothFlips = new Chart(ctx.getContext('2d'), {
        type: 'bar',
        data: {
            labels: flipsData.map(d => d.transition).slice(0, 10), // Limit to 10 for readability
            datasets
        },
        options: {
            responsive: true,
            maintainAspectRatio: false,
            plugins: {
                legend: { display: false }
            },
            scales: {
                x: { stacked: true },
                y: { 
                    stacked: true,
                    beginAtZero: true,
                    ticks: { precision: 0 }
                }
            }
        }
    });
    
    // Update table
    tbody.innerHTML = '';
    flipsData.slice(0, 10).forEach(data => {
        const row = tbody.insertRow();
        row.innerHTML = `
            <td>${data.transition}</td>
            <td>${data.total}</td>
            <td>${data.byParty['ALP'] || 0}</td>
            <td>${data.byParty['LIB'] || 0}</td>
            <td>${data.byParty['GRN'] || 0}</td>
            <td>${data.byParty['IND'] || 0}</td>
        `;
    });
}

        
        // Data loading functions
        function loadStatewideData(year) {
            const data = getCurrentData(year, 'state', '', '', '');
            
            // Process party performance
            const partyVotes = {};
            const partyCandidates = {};
            
            data.forEach(row => {
                const party = normalizeParty(row.p || 'IND');
                if (party !== 'INF') {
                    if (!partyVotes[party]) {
                        partyVotes[party] = 0;
                        partyCandidates[party] = 0;
                    }
                    partyVotes[party] += row.v;
                    partyCandidates[party]++;
                }
            });
            
            // Get seat data
            const seatData = currentElectionType === 'state' && SEAT_RESULTS.state[year] 
                ? SEAT_RESULTS.state[year] 
                : [];
            
            // Aggregate seats by party
            const partySeats = {};
            seatData.forEach(result => {
                const normalizedParty = normalizeParty(result.party);
                if (!partySeats[normalizedParty]) {
                    partySeats[normalizedParty] = 0;
                }
                partySeats[normalizedParty] += result.seats_won;
            });
            
            // Update party table
            const tbody = document.getElementById('partyTableBody');
            if (tbody) {
                tbody.innerHTML = '';
                const totalVotes = Object.values(partyVotes).reduce((a, b) => a + b, 0);
                
                Object.entries(partyVotes)
                    .sort((a, b) => b[1] - a[1])
                    .forEach(([party, votes]) => {
                        const row = tbody.insertRow();
                        const seats = partySeats[party] || 0;
                        row.innerHTML = `
                            <td><span class="party-badge" style="background: ${getPartyColor(party)}">${getPartyName(party)}</span></td>
                            <td>${votes.toLocaleString()}</td>
                            <td>${((votes / totalVotes) * 100).toFixed(1)}%</td>
                            <td>${seats}</td>
                        `;
                    });
            }
            
            // Update seat table
            const seatTableBody = document.getElementById('seatTableBody');
            if (seatTableBody && seatData.length > 0) {
                seatTableBody.innerHTML = '';
                const electorates = [...new Set(seatData.map(s => s.electorate))];
                
                electorates.forEach(elec => {
                    const row = seatTableBody.insertRow();
                    const elecSeats = seatData.filter(s => s.electorate === elec).map(s => ({...s, party: normalizeParty(s.party)}));
                    const labor = elecSeats.find(s => s.party === 'ALP')?.seats_won || 0;
                    const liberal = elecSeats.find(s => s.party === 'LIB')?.seats_won || 0;
                    const greens = elecSeats.find(s => s.party === 'GRN')?.seats_won || 0;
                    const other = elecSeats.filter(s => !['ALP','LIB','GRN'].includes(s.party))
                        .reduce((sum, s) => sum + s.seats_won, 0);
                    
                    row.innerHTML = `
                        <td>${elec}</td>
                        <td>${labor}</td>
                        <td>${liberal}</td>
                        <td>${greens}</td>
                        <td>${other}</td>
                    `;
                });
            }
            
            // Update booth winners table
            const boothBody = document.getElementById('boothTableBody');
            if (boothBody) {
                const boothWinners = calculateBoothWinners(year, '');
                boothBody.innerHTML = '';
                
                boothWinners.forEach(booth => {
                    const row = boothBody.insertRow();
                    row.innerHTML = `
                        <td>${booth.name}</td>
                        <td>${booth.electorate}</td>
                        <td><span class="party-badge" style="background: ${getPartyColor(booth.party)}">${getPartyName(booth.party)}</span></td>
                        <td>${booth.votes.toLocaleString()}</td>
                    `;
                });
            }
            
            // Create charts
            createPartyChart(partyVotes);
            createSeatChart(partySeats);
        }
        
        function loadElectorateData(year, electorate) {
            const data = getCurrentData(year, 'electorate', electorate, '', '');
            
            // Process party performance
            const partyVotes = {};
            
            data.forEach(row => {
                const party = normalizeParty(row.p || 'IND');
                if (party !== 'INF') {
                    if (!partyVotes[party]) {
                        partyVotes[party] = 0;
                    }
                    partyVotes[party] += row.v;
                }
            });
            
            // Update tables
            const partyBody = document.getElementById('partyTableBody');
            if (partyBody) {
                partyBody.innerHTML = '';
                const totalVotes = Object.values(partyVotes).reduce((a, b) => a + b, 0);
                
                Object.entries(partyVotes)
                    .sort((a, b) => b[1] - a[1])
                    .forEach(([party, votes]) => {
                        const row = partyBody.insertRow();
                        const candidates = data.filter(d => normalizeParty(d.p) === party).length;
                        row.innerHTML = `
                            <td><span class="party-badge" style="background: ${getPartyColor(party)}">${getPartyName(party)}</span></td>
                            <td>${votes.toLocaleString()}</td>
                            <td>${((votes / totalVotes) * 100).toFixed(1)}%</td>
                            <td>${candidates}</td>
                        `;
                    });
            }
            
            // Update candidate table
            const candidateBody = document.getElementById('candidateTableBody');
            if (candidateBody) {
                candidateBody.innerHTML = '';
                const sortedCandidates = [...data].sort((a, b) => b.v - a.v);
                const totalVotes = Object.values(partyVotes).reduce((a, b) => a + b, 0);
                
                sortedCandidates.forEach(cand => {
                    const row = candidateBody.insertRow();
                    row.innerHTML = `
                        <td>${cand.c}</td>
                        <td style="color: ${getPartyColor(cand.p)}">${getPartyName(cand.p)}</td>
                        <td>${cand.v.toLocaleString()}</td>
                        <td>${((cand.v / totalVotes) * 100).toFixed(2)}%</td>
                    `;
                });
            }
            
            // Update booth winners
            const boothBody = document.getElementById('boothTableBody');
            const boothWinners = calculateBoothWinners(year, electorate || '');
            
            if (boothBody) {
                boothBody.innerHTML = '';
                
                boothWinners.forEach(booth => {
                    const row = boothBody.insertRow();
                    row.innerHTML = `
                        <td>${booth.name}</td>
                        <td><span class="party-badge" style="background: ${getPartyColor(booth.party)}">${getPartyName(booth.party)}</span></td>
                        <td>${booth.votes.toLocaleString()}</td>
                    `;
                });
            }
            
            // Create charts
            createPartyChart(partyVotes);
            createCandidateChart(data);
        }
        
        function loadBoothData(year, electorate, booth) {
            const data = getCurrentData(year, 'booth', electorate, booth, '');
            const candidateTotals = {};

            // Pre-compute total votes per candidate across the current scope
            data.forEach(candidate => {
                let total = 0;
                if (candidate.b && Array.isArray(candidate.b)) {
                    candidate.b.forEach(b => {
                        if (isPhysicalBooth(b.n)) total += b.v;
                    });
                }
                candidateTotals[candidate.c] = total;
            });

            if (!booth || booth === '') {
                // Aggregate across all (physical) booths within the selected electorate (or statewide if none)
                const boothResults = [];
                data.forEach(candidate => {
                    const total = candidateTotals[candidate.c] || 0;
                    boothResults.push({
                        candidate: candidate.c,
                        party: candidate.p,
                        votes: total
                    });
                });

                // Populate results table
                const tbody = document.getElementById('boothResultsBody');
                if (tbody) {
                    tbody.innerHTML = '';
                    const totalVotes = boothResults.reduce((sum, r) => sum + r.votes, 0);
                    boothResults
                        .slice()
                        .sort((a, b) => b.votes - a.votes)
                        .forEach(result => {
                            const row = tbody.insertRow();
                            row.innerHTML = `
                                <td>${result.candidate}</td>
                                <td style="color: ${getPartyColor(result.party)}">${getPartyName(result.party)}</td>
                                <td>${result.votes.toLocaleString()}</td>
                                <td>${totalVotes ? ((result.votes / totalVotes) * 100).toFixed(1) : '0.0'}%</td>
                                <td>${candidateTotals[result.candidate] ? ((result.votes / candidateTotals[result.candidate]) * 100).toFixed(1) : '0.0'}%</td>
                            `;
                        });
                }

                // Draw chart with Top 15 default + toggle
                const sortedAll = boothResults.slice().sort((a, b) => b.votes - a.votes);
                const TOP_N = 15;
                createBoothVoteChart(sortedAll.slice(0, TOP_N));
                const topBtn = document.getElementById('voteTopBtn');
                const allBtn = document.getElementById('voteAllBtn');
                if (topBtn && allBtn) {
                    topBtn.classList.add('active');
                    allBtn.classList.remove('active');
                    topBtn.onclick = () => {
                        topBtn.classList.add('active');
                        allBtn.classList.remove('active');
                        createBoothVoteChart(sortedAll.slice(0, TOP_N));
                    };
                    allBtn.onclick = () => {
                        allBtn.classList.add('active');
                        topBtn.classList.remove('active');
                        createBoothVoteChart(sortedAll);
                    };
                }
                return;
            }

            
            // Get results for specific booth
            const boothResults = [];
            data.forEach(candidate => {
                if (candidate.b && Array.isArray(candidate.b)) {
                    const boothData = candidate.b.find(b => b.n === booth);
                    if (boothData) {
                        boothResults.push({
                            candidate: candidate.c,
                            party: candidate.p,
                            votes: boothData.v
                        });
                    }
                }
            });
            
            // Sort by votes
            boothResults.sort((a, b) => b.votes - a.votes);
            
            // Update table
            const tbody = document.getElementById('boothResultsBody');
            if (tbody) {
                tbody.innerHTML = '';
                const totalVotes = boothResults.reduce((sum, r) => sum + r.votes, 0);
                
                boothResults.forEach(result => {
                    const row = tbody.insertRow();
                    row.innerHTML = `
                        <td>${result.candidate}</td>
                        <td style="color: ${getPartyColor(result.party)}">${getPartyName(result.party)}</td>
                        <td>${result.votes.toLocaleString()}</td>
                        <td>${((result.votes / totalVotes) * 100).toFixed(1)}%</td>
                        <td>${candidateTotals[result.candidate] ? ((result.votes / candidateTotals[result.candidate]) * 100).toFixed(1) : '0.0'}%</td>
                    `;
                });
            }
            
            // Create vote distribution chart
            boothResults.sort((a, b) => b.votes - a.votes);
            const TOP_N = 15;
            createBoothVoteChart(boothResults.slice(0, TOP_N));
            const topBtn = document.getElementById('voteTopBtn');
            const allBtn = document.getElementById('voteAllBtn');
            if (topBtn && allBtn) {
                topBtn.onclick = () => {
                    topBtn.classList.add('active');
                    allBtn.classList.remove('active');
                    createBoothVoteChart(boothResults.slice(0, TOP_N));
                };
                allBtn.onclick = () => {
                    allBtn.classList.add('active');
                    topBtn.classList.remove('active');
                    createBoothVoteChart(boothResults);
                };
            }}
        
        function loadCandidateData(year, candidate) {
            const data = getCurrentData(year, 'candidate', '', '', candidate);

            if (!candidate || data.length === 0) {
                document.getElementById('primaryVotes').textContent = '—';
                return;
            }

            const candidateData = data[0];
            const electorate = candidateData.d;
            const party = candidateData.p;
            const normalizedParty = normalizeParty(party);

            const electorateData = getCurrentData(year, 'electorate', electorate, '', '');

            const totalVotes = candidateData.v;
            const electorateTotalVotes = electorateData.reduce((sum, c) => sum + c.v, 0);
            const primaryPercent = (totalVotes / electorateTotalVotes * 100).toFixed(2);

            const partyCandidates = electorateData.filter(c => normalizeParty(c.p) === normalizedParty);
            const partyTotalVotes = partyCandidates.reduce((sum, c) => sum + c.v, 0);
            const partyShare = partyTotalVotes > 0 ? (totalVotes / partyTotalVotes * 100).toFixed(1) : 0;

            const candidateNorm = normalizeCandidateName(candidate);

            const sortedCandidates = [...electorateData].sort((a, b) => b.v - a.v);
            const overallRank = sortedCandidates.findIndex(c => normalizeCandidateName(c.c) === candidateNorm) + 1;
            const sortedParty = partyCandidates.sort((a, b) => b.v - a.v);
            const partyRank = sortedParty.findIndex(c => normalizeCandidateName(c.c) === candidateNorm) + 1;

            const statewideData = getCurrentData(year, 'state', '', '', '');
            const statewideParty = statewideData.filter(c => normalizeParty(c.p) === normalizedParty);
            const sortedStateParty = statewideParty.sort((a, b) => b.v - a.v);
            const statewidePartyRank = sortedStateParty.findIndex(c => normalizeCandidateName(c.c) === candidateNorm) + 1;

            document.getElementById('primaryVotes').textContent = totalVotes.toLocaleString();
            document.getElementById('primaryPercent').textContent = `${primaryPercent}% of electorate`;
            document.getElementById('partyShare').textContent = `${partyShare}%`;
            document.getElementById('partyRank').textContent = `#${partyRank}`;
            document.getElementById('partyRankLabel').textContent = `of ${partyCandidates.length} ${getPartyName(party)} candidates`;
            document.getElementById('overallRank').textContent = `#${overallRank}`;
            document.getElementById('overallRankLabel').textContent = `of ${sortedCandidates.length} candidates`;

            const boothResults = candidateData.b || [];
            const physicalBooths = boothResults.filter(b => isPhysicalBooth(b.n));

            const boothStats = physicalBooths.map(booth => {
                let boothTotal = 0;
                electorateData.forEach(c => {
                    const b = (c.b || []).find(b => b.n === booth.n);
                    if (b) boothTotal += b.v;
                });
                const percentage = boothTotal > 0 ? (booth.v / boothTotal * 100) : 0;
                return { name: booth.n, votes: booth.v, percentage, total: boothTotal };
            });

            // Sort booths by raw vote count to identify highest and lowest performing booths
            const sortedBooths = [...boothStats].sort((a, b) => b.votes - a.votes);

            const prevYear = getPreviousYear(year);
            let prevData = null;
            let prevElectorateData = null;
            let swing = null;

            if (prevYear) {
                const prevYearData = currentElectionType === 'state' ? ELECTION_DATA.state[prevYear] : ELECTION_DATA.lc[prevYear];
                if (prevYearData) {
                    prevData = prevYearData.find(c => normalizeCandidateName(c.c) === candidateNorm && c.d === electorate);
                    prevElectorateData = prevYearData.filter(c => c.d === electorate);
                    if (prevData) {
                        const prevTotal = prevElectorateData.reduce((sum, c) => sum + c.v, 0);
                        const prevPercent = (prevData.v / prevTotal * 100);
                        swing = (parseFloat(primaryPercent) - prevPercent).toFixed(2);
                    }
                }
            }

            const histBody = document.getElementById('historicalComparisonBody');
            if (histBody) {
                if (prevData && swing !== null) {
                    const prevTotal = prevElectorateData.reduce((sum, c) => sum + c.v, 0);
                    const prevPercent = (prevData.v / prevTotal * 100).toFixed(2);
                    const prevRank = [...prevElectorateData].sort((a, b) => b.v - a.v).findIndex(c => normalizeCandidateName(c.c) === candidateNorm) + 1;
                    const rankChange = prevRank - overallRank;

                    histBody.innerHTML = `
                <tr>
                    <td>Primary Votes</td>
                    <td>${totalVotes.toLocaleString()}</td>
                    <td>${prevData.v.toLocaleString()}</td>
                    <td style="color: ${totalVotes > prevData.v ? 'green' : 'red'}">
                        ${totalVotes > prevData.v ? '+' : ''}${(totalVotes - prevData.v).toLocaleString()}
                    </td>
                </tr>
                <tr>
                    <td>Vote %</td>
                    <td>${primaryPercent}%</td>
                    <td>${prevPercent}%</td>
                    <td style="color: ${swing > 0 ? 'green' : 'red'}">
                        ${swing > 0 ? '+' : ''}${swing}pp
                    </td>
                </tr>
                <tr>
                    <td>Overall Rank</td>
                    <td>#${overallRank}</td>
                    <td>#${prevRank}</td>
                    <td style="color: ${rankChange > 0 ? 'green' : 'red'}">
                        ${rankChange > 0 ? '↑' : rankChange < 0 ? '↓' : '—'}${Math.abs(rankChange)}
                    </td>
                </tr>
            `;
                } else {
                    histBody.innerHTML = '<tr><td colspan="4">No previous election data available</td></tr>';
                }
            }

            const boothSwings = new Map();
            if (prevData && prevData.b) {
                physicalBooths.forEach(booth => {
                    const prevBooth = prevData.b.find(b => b.n === booth.name);
                    if (prevBooth) {
                        let prevBoothTotal = 0;
                        prevElectorateData.forEach(c => {
                            const b = (c.b || []).find(b => b.n === booth.name);
                            if (b) prevBoothTotal += b.v;
                        });
                        if (prevBoothTotal > 0) {
                            const currentPct = booth.percentage;
                            const prevPct = (prevBooth.v / prevBoothTotal * 100);
                            boothSwings.set(booth.name, (currentPct - prevPct).toFixed(2));
                        }
                    }
                });
            }

            const topBody = document.getElementById('topBoothsBody');
            if (topBody) {
                topBody.innerHTML = '';
                sortedBooths.slice(0, 10).forEach(booth => {
                    const swing = boothSwings.get(booth.name) || '—';
                    const swingColor = swing !== '—' ? (parseFloat(swing) > 0 ? 'green' : 'red') : '';
                    const row = topBody.insertRow();
                    row.innerHTML = `
                <td>${booth.name}</td>
                <td>${booth.votes.toLocaleString()}</td>
                <td>${booth.percentage.toFixed(1)}%</td>
                <td style="color: ${swingColor}">${swing !== '—' ? (parseFloat(swing) > 0 ? '+' : '') + swing + 'pp' : '—'}</td>
            `;
                });
            }

            const bottomBody = document.getElementById('bottomBoothsBody');
            if (bottomBody) {
                bottomBody.innerHTML = '';
                sortedBooths.slice(-10).reverse().forEach(booth => {
                    const swing = boothSwings.get(booth.name) || '—';
                    const swingColor = swing !== '—' ? (parseFloat(swing) > 0 ? 'green' : 'red') : '';
                    const row = bottomBody.insertRow();
                    row.innerHTML = `
                <td>${booth.name}</td>
                <td>${booth.votes.toLocaleString()}</td>
                <td>${booth.percentage.toFixed(1)}%</td>
                <td style="color: ${swingColor}">${swing !== '—' ? (parseFloat(swing) > 0 ? '+' : '') + swing + 'pp' : '—'}</td>
            `;
                });
            }

            const formatList = items => {
                if (items.length === 0) return '';
                if (items.length === 1) return items[0];
                if (items.length === 2) return `${items[0]} and ${items[1]}`;
                return `${items.slice(0, -1).join(', ')}, and ${items[items.length - 1]}`;
            };

            const topBoothNames = sortedBooths.slice(0, 4).map(b => `${b.name} (${b.votes.toLocaleString()})`);
            const bottomBoothNames = sortedBooths.slice(-5).map(b => `${b.name} (${b.votes.toLocaleString()})`).reverse();

            const electAhead = sortedParty[partyRank - 2];
            const electBehind = sortedParty[partyRank];
            let electRankText = '';
            if (electAhead && electBehind) {
                electRankText = `, trailing ${electAhead.c} and ahead of ${electBehind.c}`;
            } else if (electAhead) {
                electRankText = `, trailing ${electAhead.c}`;
            } else if (electBehind) {
                electRankText = `, leading ${electBehind.c}`;
            }

            const stateAhead = sortedStateParty[statewidePartyRank - 2];
            const stateBehind = sortedStateParty[statewidePartyRank];
            let stateRankText = '';
            if (stateAhead && stateBehind) {
                stateRankText = `, trailing ${stateAhead.c} (${stateAhead.d}) and ahead of ${stateBehind.c} (${stateBehind.d})`;
            } else if (stateAhead) {
                stateRankText = `, trailing ${stateAhead.c} (${stateAhead.d})`;
            } else if (stateBehind) {
                stateRankText = `, leading ${stateBehind.c} (${stateBehind.d})`;
            }

            let summary = `${candidate} achieved a first preference result of ${totalVotes.toLocaleString()} or ${primaryPercent}%.`;
            const electorateComparison = normalizedParty === 'IND' ? 'other independent candidates' : 'others in their party';
            const statewideComparison = normalizedParty === 'IND' ? 'all other independent candidates' : `all other ${getPartyName(party)} candidates`;
            summary += ` They ranked #${partyRank} compared to ${electorateComparison} within the electorate of ${electorate}${electRankText}, and #${statewidePartyRank} compared to ${statewideComparison} across all electorates${stateRankText}.`;
            if (topBoothNames.length > 0) {
                summary += ` Their highest performing booths were ${formatList(topBoothNames)}.`;
            }
            if (bottomBoothNames.length > 0) {
                summary += ` While their lowest performing booths were ${formatList(bottomBoothNames)}.`;
            }
            if (prevData && swing !== null) {
                const perf = parseFloat(swing) > 0 ? 'better' : parseFloat(swing) < 0 ? 'worse' : 'the same';
                summary += ` Compared to their previous election results, they achieved a ${perf} result, with an overall swing of ${parseFloat(swing) > 0 ? '+' : ''}${swing}%.`;
            } else {
                summary += ' No previous election data available for comparison.';
            }
            const summaryEl = document.getElementById('candidateSummary');
            if (summaryEl) summaryEl.textContent = summary;

            const percentages = boothStats.map(b => b.percentage);
            percentages.sort((a, b) => a - b);

            const median = percentages.length > 0 ? percentages[Math.floor(percentages.length / 2)] : 0;
            const q1 = percentages[Math.floor(percentages.length * 0.25)];
            const q3 = percentages[Math.floor(percentages.length * 0.75)];
            const iqr = q3 - q1;

            const mean = percentages.reduce((sum, p) => sum + p, 0) / percentages.length;
            const variance = percentages.reduce((sum, p) => sum + Math.pow(p - mean, 2), 0) / percentages.length;
            const stdDev = Math.sqrt(variance);
            const cv = mean > 0 ? (stdDev / mean * 100) : 0;

            const outliers = boothStats.filter(b => Math.abs(b.percentage - mean) > 2 * stdDev);

            document.getElementById('medianBooth').textContent = `${median.toFixed(1)}%`;
            document.getElementById('iqrBooth').textContent = `${iqr.toFixed(1)}pp`;
            document.getElementById('cvBooth').textContent = `${cv.toFixed(1)}%`;
            document.getElementById('outlierCount').textContent = outliers.length;

            const outlierBody = document.getElementById('outlierBoothsBody');
            if (outlierBody) {
                if (outliers.length > 0) {
                    outlierBody.innerHTML = '';
                    outliers.forEach(booth => {
                        const deviation = ((booth.percentage - mean) / stdDev).toFixed(2);
                        const type = booth.percentage > mean ? 'Overperforming' : 'Underperforming';
                        const row = outlierBody.insertRow();
                        row.innerHTML = `
                    <td>${booth.name}</td>
                    <td>${booth.percentage.toFixed(1)}%</td>
                    <td>${deviation}σ</td>
                    <td style="color: ${booth.percentage > mean ? 'green' : 'red'}">${type}</td>
                `;
                    });
                } else {
                    outlierBody.innerHTML = '<tr><td colspan="4">No significant outliers detected</td></tr>';
                }
            }

            createCandidateTrendChart(candidate, electorate);
            createDistributionChart(boothStats);
            createCandidateBoothMap(boothStats, electorate);
        }

        function createCandidateTrendChart(candidate, electorate) {
            const ctx = document.getElementById('trendChart');
            if (!ctx) return;
            const years = getAvailableYears();
            const trendData = [];

            const target = normalizeCandidateName(candidate);

            years.forEach(year => {
                const yearData = currentElectionType === 'state' ? ELECTION_DATA.state[year] : ELECTION_DATA.lc[year];
                if (yearData) {
                    const candData = yearData.find(c => normalizeCandidateName(c.c) === target && c.d === electorate);
                    if (candData) {
                        const elecData = yearData.filter(c => c.d === electorate);
                        const total = elecData.reduce((sum, c) => sum + c.v, 0);
                        const percent = (candData.v / total * 100);
                        trendData.push({ year, percent });
                    }
                }
            });

            if (charts.trend) charts.trend.destroy();
            if (trendData.length > 0) {
                const maxPercentage = Math.max(...trendData.map(d => d.percent));
                const yMax = maxPercentage < 60 ? 60 : 100;

                charts.trend = new Chart(ctx.getContext('2d'), {
                    type: 'line',
                    data: {
                        labels: trendData.map(d => d.year),
                        datasets: [{
                            label: 'Primary Vote %',
                            data: trendData.map(d => d.percent),
                            borderColor: '#4A5A6A',
                            backgroundColor: 'rgba(74, 90, 106, 0.1)',
                            tension: 0.2
                        }]
                    },
                        options: {
                            responsive: true,
                            maintainAspectRatio: false,
                            plugins: { legend: { display: false } },
                            scales: {
                                y: {
                                beginAtZero: true,
                                max: yMax,
                                ticks: { callback: value => value + '%' }
                            }
                        }
                    }
                });
            }
        }

        function createDistributionChart(boothStats) {
            const ctx = document.getElementById('distributionChart');
            if (!ctx) return;
            const percentages = boothStats.map(b => b.percentage);
            const min = Math.min(...percentages);
            const max = Math.max(...percentages);
            const binCount = 10;
            const binSize = (max - min) / binCount;

            const bins = [];
            const binLabels = [];
            for (let i = 0; i < binCount; i++) {
                const binMin = min + i * binSize;
                const binMax = binMin + binSize;
                const count = percentages.filter(p => p >= binMin && p < binMax).length;
                bins.push(count);
                binLabels.push(`${binMin.toFixed(1)}-${binMax.toFixed(1)}%`);
            }

            if (charts.distribution) charts.distribution.destroy();
            charts.distribution = new Chart(ctx.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: binLabels,
                    datasets: [{
                        label: 'Number of Booths',
                        data: bins,
                        backgroundColor: '#4A5A6A'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: { legend: { display: false } },
                    scales: {
                        y: { beginAtZero: true, ticks: { precision: 0 } },
                        x: { title: { display: true, text: 'Vote Share Range' } }
                    }
                }
            });
        }

        function createCandidateBoothMap(boothStats, electorate) {
            if (boothMap) {
                boothMap.remove();
            }
            boothMap = L.map('boothMap').setView([-42.0, 147.0], 7);
            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(boothMap);
            mapMarkers = L.layerGroup().addTo(boothMap);

            const percentages = boothStats.map(b => b.percentage);
            const maxPct = Math.max(...percentages);
            const minPct = Math.min(...percentages);

            boothStats.forEach(booth => {
                const coords = POLLING_PLACES[booth.name] || POLLING_PLACES[keyForBooth(booth.name)];
                if (coords && coords.lat && coords.lng) {
                    const intensity = (booth.percentage - minPct) / (maxPct - minPct);
                    const color = `hsl(${120 * intensity}, 70%, 50%)`;
                    const icon = L.divIcon({
                        className: 'custom-div-icon',
                        html: `<div style="background-color:${color}; width: 20px; height: 20px; border-radius: 50%; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3);"></div>`,
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });
                    const marker = L.marker([coords.lat, coords.lng], {icon});
                    const popupContent = `
                <div class="booth-popup">
                    <h3>${booth.name}</h3>
                    <p><strong>Votes:</strong> ${booth.votes.toLocaleString()}</p>
                    <p><strong>Share:</strong> ${booth.percentage.toFixed(1)}%</p>
                </div>`;
                    marker.bindPopup(popupContent);
                    mapMarkers.addLayer(marker);
                }
            });

            const legend = L.control({position: 'bottomright'});
            legend.onAdd = function(map) {
                const div = L.DomUtil.create('div', 'map-legend');
                div.innerHTML = `
            <h4>Performance Scale</h4>
            <div style="background: linear-gradient(to right, hsl(0, 70%, 50%), hsl(60, 70%, 50%), hsl(120, 70%, 50%)); height: 20px; margin: 5px 0;"></div>
            <div style="display: flex; justify-content: space-between; font-size: 0.8rem;">
                <span>${minPct.toFixed(1)}%</span>
                <span>${maxPct.toFixed(1)}%</span>
            </div>`;
                return div;
            };
            legend.addTo(boothMap);
            if (mapMarkers.getLayers().length > 0) {
                boothMap.fitBounds(mapMarkers.getBounds(), {padding: [50, 50]});
            }
        }
        
        // Chart creation functions
        function createPartyChart(partyVotes) {
            const ctx = document.getElementById('partyChart');
            if (!ctx) return;
            
            const totalVotes = Object.values(partyVotes).reduce((a, b) => a + b, 0);
            const sortedParties = Object.entries(partyVotes)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);

            const percentages = sortedParties.map(p => totalVotes ? (p[1] / totalVotes * 100) : 0);
            const maxPercentage = Math.max(...percentages);
            const yMax = maxPercentage < 60 ? 60 : 100;

            if (charts.party) charts.party.destroy();

            charts.party = new Chart(ctx.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: sortedParties.map(p => getPartyName(p[0])),
                    datasets: [{
                        label: 'Vote %',
                        data: percentages,
                        backgroundColor: sortedParties.map(p => getPartyColor(p[0]))
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: yMax,
                            ticks: {
                                callback: value => value + '%'
                            }
                        }
                    }
                }
            });
        }
        
        function createSeatChart(partySeats) {
            const ctx = document.getElementById('seatChart');
            if (!ctx) return;
            
            // Sort parties by seats won (descending) so bars display high to low
            const sorted = Object.entries(partySeats)
                .sort((a, b) => b[1] - a[1]);
            const parties = sorted.map(entry => entry[0]);
            const seats = sorted.map(entry => entry[1]);
            
            if (charts.seats) charts.seats.destroy();
            
            charts.seats = new Chart(ctx.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: parties.map(p => getPartyName(p)),
                    datasets: [{
                        data: seats,
                        backgroundColor: parties.map(p => getPartyColor(p))
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false, position: 'right' }
                    }
                }
            });
        }
        
        function createCandidateChart(candidates) {
            const ctx = document.getElementById('candidateChart');
            if (!ctx) return;
            
            const sorted = [...candidates].sort((a, b) => b.v - a.v).slice(0, 15);
            
            if (charts.candidate) charts.candidate.destroy();
            
            charts.candidate = new Chart(ctx.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: sorted.map(c => c.c),
                    datasets: [{
                        label: 'Votes',
                        data: sorted.map(c => c.v),
                        backgroundColor: sorted.map(c => getPartyColor(c.p))
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }
        
        function createBoothVoteChart(boothResults) {
            const ctx = document.getElementById('voteChart');
            if (!ctx) return;
            
            if (charts.vote) charts.vote.destroy();
            
            charts.vote = new Chart(ctx.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: boothResults.map(r => `${r.candidate} (${getPartyName(r.party)})`),
                    datasets: [{
                        data: boothResults.map(r => r.votes),
                        backgroundColor: boothResults.map(r => getPartyColor(r.party))
                    }]
                },
                options: {
                    plugins: { legend: { display: false } },
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false
                }
            });
        }
        
        
        function createBoothPartyTrendChart(booth) {
            const ctx = document.getElementById('boothPartyTrendChart');
            if (!ctx) return;

            const years = getAvailableYears();
            const parties = new Set();

            years.forEach(year => {
                const data = currentElectionType === 'state' ? ELECTION_DATA.state[year] : ELECTION_DATA.lc[year];
                if (!data) return;
                data.forEach(candidate => {
                    const party = normalizeParty(candidate.p);
                    if (candidate.b && Array.isArray(candidate.b)) {
                        if (booth) {
                            const boothData = candidate.b.find(b => b.n === booth);
                            if (boothData && isPhysicalBooth(boothData.n)) {
                                parties.add(party);
                            }
                        } else {
                            candidate.b.forEach(b => {
                                if (isPhysicalBooth(b.n)) {
                                    parties.add(party);
                                }
                            });
                        }
                    }
                });
            });

            const partyList = Array.from(parties).sort();
            const partyData = {};
            partyList.forEach(p => partyData[p] = []);

            years.forEach(year => {
                const data = currentElectionType === 'state' ? ELECTION_DATA.state[year] : ELECTION_DATA.lc[year];
                const partyVotes = {};
                let totalVotes = 0;

                if (data) {
                    data.forEach(candidate => {
                        const party = normalizeParty(candidate.p);
                        if (candidate.b && Array.isArray(candidate.b)) {
                            if (booth) {
                                const boothData = candidate.b.find(b => b.n === booth);
                                if (boothData && isPhysicalBooth(boothData.n)) {
                                    partyVotes[party] = (partyVotes[party] || 0) + boothData.v;
                                    totalVotes += boothData.v;
                                }
                            } else {
                                candidate.b.forEach(b => {
                                    if (isPhysicalBooth(b.n)) {
                                        partyVotes[party] = (partyVotes[party] || 0) + b.v;
                                        totalVotes += b.v;
                                    }
                                });
                            }
                        }
                    });
                }

                partyList.forEach(party => {
                    const votes = partyVotes[party] || 0;
                    const pct = totalVotes > 0 ? (votes / totalVotes * 100) : 0;
                    partyData[party].push(pct);
                });
            });

            if (charts.boothPartyTrend) charts.boothPartyTrend.destroy();

            charts.boothPartyTrend = new Chart(ctx.getContext('2d'), {
                type: 'line',
                data: {
                    labels: years,
                    datasets: partyList.map(party => ({
                        label: getPartyName(party),
                        data: partyData[party],
                        borderColor: getPartyColor(party),
                        backgroundColor: getPartyColor(party) + '20',
                        tension: 0.2,
                        fill: false
                    }))
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { position: 'bottom' }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            ticks: {
                                callback: value => value + '%'
                            }
                        }
                    }
                }
            });
        }

        function createBoothSelectionMap(electorate, selectedBooth = '') {
            if (boothMap) {
                boothMap.remove();
            }
            boothMap = L.map('boothMap').setView([-42.0, 147.0], 7);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(boothMap);

            mapMarkers = L.layerGroup().addTo(boothMap);

            // Show legend of party colours
            const legend = L.control({position: 'bottomright'});
            legend.onAdd = function(map) {
                const div = L.DomUtil.create('div', 'map-legend');
                div.innerHTML = `
                    <h4>Party Colors</h4>
                    <div class="legend-item">
                        <div class="legend-color" style="background: ${getPartyColor('ALP')}"></div>
                        <span>Labor</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: ${getPartyColor('LIB')}"></div>
                        <span>Liberal</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: ${getPartyColor('GRN')}"></div>
                        <span>Greens</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: ${getPartyColor('IND')}"></div>
                        <span>Independent</span>
                    </div>
                `;
                return div;
            };
            legend.addTo(boothMap);

            // Build map of booth winners for marker colouring
            const year = document.getElementById('yearSelect').value;
            const boothWinners = calculateBoothWinners(year, electorate || '');
            const winnerMap = new Map();
            boothWinners.forEach(b => winnerMap.set(keyForBooth(b.name), b));

            // For LC elections, build a map of booth names to their LC electorates
            let lcBoothMap = null;
            if (currentElectionType === 'lc') {
                lcBoothMap = new Map();
                const data = ELECTION_DATA.lc[year] || [];
                data.forEach(candidate => {
                    if (Array.isArray(candidate.b)) {
                        candidate.b.forEach(b => {
                            const key = keyForBooth(b.n);
                            if (!lcBoothMap.has(key)) {
                                lcBoothMap.set(key, candidate.d);
                            }
                        });
                    }
                });
            }

            Object.entries(POLLING_PLACES).forEach(([name, info]) => {
                const key = keyForBooth(name);
                if (currentElectionType === 'state') {
                    if (electorate && info.electorate !== electorate) return;
                } else if (currentElectionType === 'lc') {
                    if (!lcBoothMap || !lcBoothMap.has(key)) return;
                    if (electorate && lcBoothMap.get(key) !== electorate) return;
                }

                const winner = winnerMap.get(key);
                const markerColor = winner ? getPartyColor(winner.party) : getPartyColor('INF');
                const icon = L.divIcon({
                    className: 'custom-div-icon',
                    html: `<div style="background-color:${markerColor}; width: 20px; height: 20px; border-radius: 50%; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3);"></div>`,
                    iconSize: [20, 20],
                    iconAnchor: [10, 10]
                });

                const marker = L.marker([info.lat, info.lng], {icon}).addTo(mapMarkers);
                const popupElectorate = (currentElectionType === 'lc')
                    ? lcBoothMap.get(key)
                    : info.electorate;
                let popupContent = `<div class="booth-popup"><h3>${name}</h3><p><strong>Electorate:</strong> ${popupElectorate}</p>`;
                if (winner) {
                    popupContent += `<p><strong>Winner:</strong> <span class="winner" style="background: ${markerColor}">${getPartyName(winner.party)}</span></p><p><strong>Votes:</strong> ${winner.votes.toLocaleString()}</p>`;
                }
                popupContent += `</div>`;
                marker.bindPopup(popupContent);
                marker.on('click', () => {
                    const boothSelect = document.getElementById('boothSelect');
                    const options = Array.from(boothSelect.options);
                    const match = options.find(opt => keyForBooth(opt.value) === keyForBooth(name));
                    if (match) {
                        boothSelect.value = match.value;
                        updateDashboard();
                    }
                });

                if (selectedBooth && keyForBooth(selectedBooth) === keyForBooth(name)) {
                    marker.openPopup();
                    boothMap.setView([info.lat, info.lng], 12);
                }
            });

            if (mapMarkers.getLayers().length > 0) {
                boothMap.fitBounds(mapMarkers.getBounds(), { padding: [50, 50] });
            }
        }

        // Map functions
        function createBoothWinnersMap(boothWinners) {
            if (!boothMap) {
                boothMap = L.map('boothMap').setView([-42.0, 147.0], 7);
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors'
                }).addTo(boothMap);
                
                mapMarkers = L.markerClusterGroup({
                    chunkedLoading: true,
                    spiderfyOnMaxZoom: true,
                    showCoverageOnHover: false,
                    zoomToBoundsOnClick: true
                });
                
                
                // --- Dynamic clustering behaviour ---
                function _partyFilterSelected() {
                    const dd = document.getElementById('partyFilterDropdown');
                    if (!dd) return [];
                    return Array.from(dd.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.value);
                }
                function _clusterColorForSelected() {
                    const sel = _partyFilterSelected();
                    if (sel.length === 1) {
                        try { return getPartyColor(sel[0]); } catch(e) { return '#B8B8B8'; }
                    }
                    return '#B8B8B8';
                }
                if (typeof mapMarkers !== 'undefined' && mapMarkers) {
                    mapMarkers.options.iconCreateFunction = function(cluster) {
                        const count = cluster.getChildCount();
                        const color = _clusterColorForSelected();
                        const html = `<div style="
                            background:${color};
                            color:#000;
                            width:36px;height:36px;
                            line-height:36px;
                            border-radius:50%;
                            text-align:center;
                            font-weight:700;
                            box-shadow:0 0 0 2px #fff inset;
                        ">${count}</div>`;
                        return L.divIcon({ html, className: 'party-cluster', iconSize: [36,36] });
                    };
                    // Only cluster when exactly one party is selected
                    mapMarkers.options.maxClusterRadius = function(zoom) {
                        return _partyFilterSelected().length === 1 ? 80 : 0;
                    };
                    // Recompute when filter changes
                    (function wireClusterRefresh(){
                        const dd = document.getElementById('partyFilterDropdown');
                        if (!dd) return;
                        dd.querySelectorAll('input[type=checkbox]').forEach(cb => {
                            cb.addEventListener('change', function(){
                                if (mapMarkers && mapMarkers.refreshClusters) {
                                    mapMarkers.refreshClusters();
                                } else if (mapMarkers) {
                                    const m = window.boothMap || window.map;
                                    if (m) { m.removeLayer(mapMarkers); m.addLayer(mapMarkers); }
                                }
                            });
                        });
                    })();
                }
boothMap.addLayer(mapMarkers);
                
                
                // --- GeoJSON Overlay selector (State, LegCo, LGA) [attached directly to boothMap] ---
                (function setupGeoJsonOverlayToggleLocal(map) {
                    if (!map || map.__overlayCtlAdded) return;
                    map.__overlayCtlAdded = true;

                    const OVERLAY_URLS = {
                        state: 'https://raw.githubusercontent.com/williammanning68/Test-Fetch/main/State Election Electorate Boundaries.geojson',
                        legco: 'https://raw.githubusercontent.com/williammanning68/Test-Fetch/main/Legislative Council Electorate Boundaries.geojson',
                                            };

                    const state = { current: null, cache: {} };

                    async function buildLayer(key) {
                        if (state.cache[key]) return state.cache[key];
                        const resp = await fetch(OVERLAY_URLS[key]);
                        if (!resp.ok) throw new Error('Overlay fetch failed: ' + resp.status);
                        const data = await resp.json();
                        const layer = L.geoJSON(data, {
                            style: { color: '#000', weight: 1.5, fillOpacity: 0 }
                        });
                        state.cache[key] = layer;
                        return layer;
                    }

                    const OverlayCtl = L.Control.extend({
                        options: { position: 'topright' },
                        onAdd: function(map) {
                            const div = L.DomUtil.create('div', 'leaflet-bar overlay-select-control');
                            div.style.background = '#fff';
                            div.style.padding = '6px';
                            div.style.borderRadius = '8px';
                            div.style.boxShadow  = '0 1px 3px rgba(0,0,0,.2)';
                            const label = L.DomUtil.create('label', '', div);
                            label.textContent = 'Map overlay';
                            label.style.display = 'block';
                            label.style.fontSize = '12px';
                            label.style.marginBottom = '4px';
                            const sel = L.DomUtil.create('select', '', div);
                            sel.setAttribute('aria-label', 'Select map overlay');
                            sel.innerHTML = `
                                <option value="none">None</option>
                                <option value="state">State Electorates</option>
                                <option value="legco">Legislative Council</option>`;
                            L.DomEvent.disableClickPropagation(div);
                            sel.addEventListener('change', async (e) => {
                                const v = e.target.value;
                                if (state.current) { try { map.removeLayer(state.current); } catch(e){} state.current = null; }
                                if (v === 'none') return;
                                try {
                                    const layer = await buildLayer(v);
                                    state.current = layer;
                                    map.addLayer(layer);
                                } catch (e) {
                                    console.error(e);
                                    alert('Could not load overlay "' + v + '". Check the GeoJSON URL and CORS.');
                                }
                            });
                            return div;
                        }
                    });
                    map.addControl(new OverlayCtl());
                })(boothMap);
const legend = L.control({position: 'bottomright'});
                legend.onAdd = function(map) {
                    const div = L.DomUtil.create('div', 'map-legend');
                    div.innerHTML = `
                        <h4>Party Colors</h4>
                        <div class="legend-item">
                            <div class="legend-color" style="background: ${getPartyColor('ALP')}"></div>
                            <span>Labor</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: ${getPartyColor('LIB')}"></div>
                            <span>Liberal</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: ${getPartyColor('GRN')}"></div>
                            <span>Greens</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: ${getPartyColor('IND')}"></div>
                            <span>Independent</span>
                        </div>
                    `;
                    return div;
                };
                legend.addTo(boothMap);
            }
            
            mapMarkers.clearLayers();
            
            boothWinners.forEach(booth => {
                const coords = (POLLING_PLACES[booth.name] || POLLING_PLACES[keyForBooth(booth.name)]);
                
                if (coords && coords.lat && coords.lng) {
                    const markerColor = getPartyColor(booth.party);
                    
                    const icon = L.divIcon({
                        className: 'custom-div-icon',
                        html: `<div style="background-color:${markerColor}; width: 20px; height: 20px; border-radius: 50%; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3);"></div>`,
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });
                    
                    const marker = L.marker([coords.lat, coords.lng], {icon: icon});
                    
                    const popupContent = `
                        <div class="booth-popup">
                            <h3>${booth.name}</h3>
                            <p><strong>Electorate:</strong> ${booth.electorate}</p>
                            <p><strong>Winner:</strong> <span class="winner" style="background: ${markerColor}">${getPartyName(booth.party)}</span></p>
                            <p><strong>Votes:</strong> ${booth.votes.toLocaleString()}</p>
                        </div>
                    `;
                    
                    marker.bindPopup(popupContent);
                    mapMarkers.addLayer(marker);
                } else {
                    // Log missing coordinates for debugging, but don't break the map
                    console.warn(`No coordinates found for booth: ${booth.name}`);
                }
            });
            
            if (boothWinners.length > 0) {
                setTimeout(() => {
                    boothMap.fitBounds(mapMarkers.getBounds(), {padding: [50, 50]});
                }, 100);
            }
        }
        
        // Party filter functions
        function initializePartyFilter() {
            const dropdown = document.getElementById('partyFilterDropdown');
            if (!dropdown) return;
            
            while (dropdown.children.length > 1) {
                dropdown.removeChild(dropdown.lastChild);
            }
            
            const parties = ['ALP', 'LIB', 'GRN', 'IND', 'JLN', 'NAT', 'SFF'];
            
            parties.forEach(party => {
                const option = document.createElement('div');
                option.className = 'multi-select-option';
                option.innerHTML = `
                    <input type="checkbox" id="party-${party}" value="${party}" checked onchange="updatePartyFilter()">
                    <label for="party-${party}" style="color: ${getPartyColor(party)}">${getPartyName(party)}</label>
                `;
                dropdown.appendChild(option);
            });
        }
        
        function togglePartyFilter() {
            const dropdown = document.getElementById('partyFilterDropdown');
            if (dropdown) dropdown.classList.toggle('show');
        }
        
        function toggleAllParties(checkbox) {
            const checkboxes = document.querySelectorAll('#partyFilterDropdown input[type="checkbox"]:not(#party-all)');
            checkboxes.forEach(cb => cb.checked = checkbox.checked);
            updatePartyFilter();
        }
        
        function updatePartyFilter() {
            selectedParties.clear();
            const checkboxes = document.querySelectorAll('#partyFilterDropdown input[type="checkbox"]:checked:not(#party-all)');
            
            if (checkboxes.length === 0) {
                selectedParties.add('NONE');
                document.getElementById('partyFilterText').textContent = 'No parties selected';
            } else if (checkboxes.length === document.querySelectorAll('#partyFilterDropdown input[type="checkbox"]:not(#party-all)').length) {
                selectedParties.add('ALL');
                document.getElementById('partyFilterText').textContent = 'All Parties';
                document.getElementById('party-all').checked = true;
            } else {
                checkboxes.forEach(cb => selectedParties.add(cb.value));
                document.getElementById('partyFilterText').textContent = `${checkboxes.length} parties selected`;
                document.getElementById('party-all').checked = false;
            }
            
            const scope = document.getElementById('scopeSelect').value;
            if (scope === 'state' || scope === 'electorate') {
                const year = document.getElementById('yearSelect').value;
                const electorate = document.getElementById('electorateSelect').value;
                const boothWinners = calculateBoothWinners(year, electorate);
                if (boothWinners.length > 0 && boothMap) {
                    createBoothWinnersMap(boothWinners);
                }
            }
        }
        
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.multi-select-container')) {
                const dropdown = document.getElementById('partyFilterDropdown');
                if (dropdown) dropdown.classList.remove('show');
            }
        });
document.addEventListener('click', function(event) {
    if (!event.target.closest('.searchable-dropdown') && !event.target.closest('.multi-select-container')) {
        document.querySelectorAll('.searchable-dropdown-menu').forEach(menu => {
            menu.classList.remove('show');
            // Clear search inputs
            const searchInput = menu.querySelector('input');
            if (searchInput) searchInput.value = '';
            // Show all options
            menu.querySelectorAll('.searchable-dropdown-option').forEach(opt => {
                opt.classList.remove('hidden');
            });
        });
    }
});

// Add keyboard navigation for searchable dropdowns
document.addEventListener('keydown', function(event) {
    const activeDropdown = document.querySelector('.searchable-dropdown-menu.show');
    if (!activeDropdown) return;
    
    const options = Array.from(activeDropdown.querySelectorAll('.searchable-dropdown-option:not(.hidden)'));
    const currentIndex = options.findIndex(opt => opt.classList.contains('highlighted'));
    
    if (event.key === 'ArrowDown') {
        event.preventDefault();
        const nextIndex = currentIndex < options.length - 1 ? currentIndex + 1 : 0;
        options.forEach(opt => opt.classList.remove('highlighted'));
        if (options[nextIndex]) {
            options[nextIndex].classList.add('highlighted');
            options[nextIndex].scrollIntoView({ block: 'nearest' });
        }
    } else if (event.key === 'ArrowUp') {
        event.preventDefault();
        const prevIndex = currentIndex > 0 ? currentIndex - 1 : options.length - 1;
        options.forEach(opt => opt.classList.remove('highlighted'));
        if (options[prevIndex]) {
            options[prevIndex].classList.add('highlighted');
            options[prevIndex].scrollIntoView({ block: 'nearest' });
        }
    } else if (event.key === 'Enter') {
        event.preventDefault();
        const highlighted = activeDropdown.querySelector('.searchable-dropdown-option.highlighted');
        if (highlighted) {
            highlighted.click();
        }
    } else if (event.key === 'Escape') {
        activeDropdown.classList.remove('show');
    }
});




    </script>
</body>
</html>
