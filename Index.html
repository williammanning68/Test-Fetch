<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Tasmania Election Results Dashboard</title>
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />
    <style>
        :root {
            --federal-gold: #C5A572;
            --federal-navy: #4A5A6A;
            --federal-dark: #475560;
            --federal-light: #ECF0F1;
            --federal-accent: #D4AF37;
            --liberal-color: #8EAADB;
            --labor-color: #EB8989;
            --greens-color: #A8D08D;
            --independent-color: #7030A0;
            --jln-color: #FFD966;
            --nationals-color: #008000;
            --shooters-color: #805200;
            --default-color: #B8B8B8;
            --informal-color: #666666;
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background-color: var(--federal-light);
            color: var(--federal-dark);
            line-height: 1.6;
        }
        
        .header {
            background: linear-gradient(135deg, var(--federal-dark) 0%, var(--federal-dark) 100%);
            color: white;
            padding: 1.5rem;
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
            position: relative;
        }
        
.header h1 {
    font-size: 2rem;
    margin-bottom: 0.5rem;
    color: white; /* plain white text */
    background: none; /* remove background gradient */
    -webkit-background-clip: unset;
    -webkit-text-fill-color: unset;
    background-clip: unset;
}
        
       .logo {
    position: absolute;
    top: 50%;
    transform: translateY(-50%);
    right: 1.5rem;   /* unchanged */
    height: 60px;   /* unchanged */
    display: flex;
    align-items: center;
}
        .logo svg {
            height: 40px;
            width: auto;
        }
        
        .controls {
            background: white;
            padding: 1.5rem;
            margin: 1.5rem;
            border-radius: 12px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
            display: flex;
            gap: 2rem;
            flex-wrap: wrap;
            align-items: center;
        }
        
        .control-group {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }
        
        .control-group.primary {
            order: -1;
            padding-right: 1rem;
            border-right: 2px solid var(--federal-light);
        }
        
        .control-group label {
            font-weight: 600;
            color: var(--federal-navy);
            font-size: 0.9rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        select, button {
            padding: 0.6rem 1rem;
            border: 2px solid var(--federal-gold);
            border-radius: 6px;
            background: white;
            color: var(--federal-dark);
            font-size: 1rem;
            cursor: pointer;
            transition: all 0.3s ease;
        }
        
        select:hover, button:hover {
            border-color: var(--federal-accent);
            box-shadow: 0 2px 8px rgba(197, 165, 114, 0.3);
        }
        
        button {
            background: var(--federal-gold);
            color: white;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        button:hover {
            background: var(--federal-accent);
        }
        
        button.active {
            background: var(--federal-navy);
            border-color: var(--federal-navy);
        }
        
        .content {
            margin: 1.5rem;
        }
        
        .panel-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 1.5rem;
            margin-bottom: 1.5rem;
        }
        
        .panel {
            background: white;
            border-radius: 12px;
            padding: 1.5rem;
            box-shadow: 0 2px 10px rgba(0,0,0,0.05);
        }
        
        .panel.full-width {
            grid-column: 1 / -1;
        }
        
        .panel h2 {
            color: var(--federal-navy);
            margin-bottom: 1rem;
            padding-bottom: 0.5rem;
            border-bottom: 3px solid var(--federal-gold);
        }
        
        .panel h3 {
            color: var(--federal-navy);
            margin-bottom: 0.75rem;
            font-size: 1.1rem;
        }
        
        .chart-container {
            height: 400px;
            margin-bottom: 2rem;
            position: relative;
        }
        
        .chart-container.small {
            height: 250px;
            margin-bottom: 1rem;
        }
        
        .table-container {
            max-height: 400px;
            overflow-y: auto;
            border: 1px solid var(--federal-light);
            border-radius: 8px;
        }
        
        .table-container.small {
            max-height: 250px;
        }
        
        table {
            width: 100%;
            border-collapse: collapse;
        }
        
        th {
            background: var(--federal-navy);
            color: white;
            padding: 0.8rem;
            text-align: left;
            position: sticky;
            top: 0;
            z-index: 10;
        }
        
        td {
            padding: 0.6rem 0.8rem;
            border-bottom: 1px solid var(--federal-light);
        }
        
        tr:hover {
            background: rgba(197, 165, 114, 0.1);
        }
        
        .loading {
            text-align: center;
            padding: 3rem;
            color: var(--federal-navy);
        }
        
        canvas {
            max-height: 400px !important;
        }
        
        .multi-select-container {
            position: relative;
            min-width: 200px;
        }
        
        .multi-select-dropdown {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: white;
            border: 2px solid var(--federal-gold);
            border-radius: 6px;
            max-height: 250px;
            overflow-y: auto;
            display: none;
            z-index: 100;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
        }
        
        .multi-select-dropdown.show {
            display: block;
        }
        
        .multi-select-option {
            padding: 0.5rem;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }
        
        .multi-select-option:hover {
            background: var(--federal-light);
        }
        
        .multi-select-option input[type="checkbox"] {
            accent-color: var(--federal-gold);
        }
        
        .multi-select-display {
            padding: 0.6rem 1rem;
            border: 2px solid var(--federal-gold);
            border-radius: 6px;
            background: white;
            cursor: pointer;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }
        
        .booth-stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 1rem;
            margin-bottom: 1.5rem;
        }
        
        .stat-card {
            background: var(--federal-light);
            padding: 1rem;
            border-radius: 8px;
            border-left: 4px solid var(--federal-gold);
        }
        
        .stat-card h3 {
            color: var(--federal-navy);
            font-size: 0.9rem;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }
        
        .stat-value {
            font-size: 1.8rem;
            font-weight: bold;
            color: var(--federal-dark);
        }
        
        .stat-label {
            font-size: 0.85rem;
            color: #666;
            margin-top: 0.25rem;
        }
        
        .party-badge {
            display: inline-block;
            padding: 0.2rem 0.6rem;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 600;
            color: white;
            margin-right: 0.25rem;
        }
        
        .booth-filters {
            background: var(--federal-light);
            padding: 1rem;
            border-radius: 8px;
            margin-bottom: 1rem;
            display: flex;
            gap: 1rem;
            align-items: center;
            flex-wrap: wrap;
        }
        
        #boothMap {
            height: 500px;
            width: 100%;
            border-radius: 8px;
            border: 2px solid var(--federal-light);
        }
        
        .map-legend {
            background: white;
            padding: 0.75rem;
            border-radius: 6px;
            box-shadow: 0 2px 5px rgba(0,0,0,0.2);
            font-size: 0.85rem;
        }
        
        .map-legend h4 {
            margin-bottom: 0.5rem;
            font-size: 0.9rem;
            color: var(--federal-navy);
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            margin-bottom: 0.25rem;
        }
        
        .legend-color {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            border: 2px solid white;
            box-shadow: 0 1px 3px rgba(0,0,0,0.3);
        }
        
        .booth-popup {
            min-width: 200px;
        }
        
        .booth-popup h3 {
            margin: 0 0 0.5rem 0;
            color: var(--federal-navy);
            font-size: 1.1rem;
        }
        
        .booth-popup p {
            margin: 0.25rem 0;
            font-size: 0.9rem;
        }
        
        .booth-popup .winner {
            font-weight: bold;
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            display: inline-block;
            margin-top: 0.5rem;
            color: white;
        }
        
        @media (max-width: 1024px) {
            .panel-grid {
                grid-template-columns: 1fr;
            }
        }
    
/* Ensure dropdown stays above the map */
.multi-select-dropdown { z-index: 2000; }
</style>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/Chart.js/3.9.1/chart.min.js"></script>
    <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
    <script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>
</head>
<body>
    <div class="header">
        <h1>Tasmanian Election Results Dashboard</h1>
        <p>Comprehensive election data analysis for State and Legislative Council elections</p>
        <p style="font-size: 0.85rem; opacity: 0.8; margin-top: 0.5rem;"></p>
<div class="logo">
          <img
  src="https://cdn.jsdelivr.net/gh/williammanning68/Test-Fetch@237dcd83d094fc337de46388e743f68cf4023087/Federal%20Group%20Logo.png"
  alt="Federal Group logo"
  width="455" height="118" />
        </div>
    </div>


    <div class="controls">
        <div class="control-group primary">
            <label>View Scope</label>
            <select id="scopeSelect" onchange="updateDashboard()">
                <option value="state">Statewide</option>
                <option value="electorate">Electorate</option>
                <option value="booth">Booth</option>
                                <option value="boothAnalysis">Booth Analysis</option>
<option value="candidate">Individual Candidate</option>
                <option value="historical">Historical Trends</option>
            </select>
        </div>
        
        <div class="control-group">
            <label>Election Type</label>
            <div style="display: flex; gap: 0.5rem;">
                <button id="btnState" class="active" onclick="switchElectionType('state')">State Election</button>
                <button id="btnLC" onclick="switchElectionType('lc')">Legislative Council</button>
            </div>
        </div>
        
        <div class="control-group" id="yearGroup">
            <label>Select Year</label>
            <select id="yearSelect" onchange="updateDashboard()">
                <option value="">Loading...</option>
            </select>
        </div>
        
        <div class="control-group" id="electorateGroup" style="display: none;">
            <label id="electorateLabel">Select Electorate</label>
            <select id="electorateSelect" onchange="updateDashboard()">
                <option value="">All Electorates</option>
            </select>
        </div>
        
        <div class="control-group" id="boothGroup" style="display: none;">
            <label>Select Booth</label>
            <select id="boothSelect" onchange="updateDashboard()">
                <option value="">All Booths</option>
            </select>
        </div>
        
        <div class="control-group" id="candidateGroup" style="display: none;">
            <label>Select Candidate</label>
            <select id="candidateSelect" onchange="updateDashboard()">
                <option value="">Select a candidate</option>
            </select>
        </div>
    </div>

    <div class="content" id="mainContent"></div>

    <script>
        // =====================================================
        // POLLING PLACE COORDINATES - Will be fetched from JSON
        // =====================================================
        let POLLING_PLACES = {};
        
        // URL for polling places data
        const POLLING_PLACES_URL = 'https://raw.githubusercontent.com/williammanning68/Test-Fetch/main/Polling%20Locations%20-%20Year%20and%20Election%20Type.json';
        
        // Function to fetch polling places data
        
        // Normalize booth names to improve lookup hit rate
        function keyForBooth(name){
            return (name || "").replace(/\s*\(.*?\)\s*$/,'').trim();
        }
    async function fetchPollingPlaces() {
            try {
                console.log('Fetching polling places data...');
                const response = await fetch(POLLING_PLACES_URL, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const raw = await response.json();
                const data = raw.POLLING_PLACES || raw;
                console.log('Polling places data fetched successfully');
                
                // Store the polling places data (unwrapped)
                POLLING_PLACES = data;
                console.log('POLLING_PLACES loaded:', Object.keys(POLLING_PLACES).length, 'locations');
                
                return true;
            } catch (error) {
                console.error('Error fetching polling places:', error);
                // Use empty object as fallback
                POLLING_PLACES = {};
                return false;
            }
        }
        
        // =====================================================
        // ELECTION DATA
        // =====================================================
        
        // Data will be fetched from GitHub
        let ELECTION_DATA = {
            state: {},
            lc: {}
        };
        
        let SEAT_RESULTS = {
            state: {},
            lc: {}
        };
        
        // GitHub data URL - Update this to your raw JSON URL
        const DATA_URL = 'https://raw.githubusercontent.com/williammanning68/Test-Fetch/main/converted_election_data_full.json';
        
        // Function to fetch data from GitHub
        async function fetchElectionData() {
            try {
                console.log('Fetching data from GitHub...');
                console.log('URL:', DATA_URL);
                
                // First fetch polling places
                const pollingPlacesLoaded = await fetchPollingPlaces();
                if (!pollingPlacesLoaded) {
                    console.warn('Polling places data could not be loaded, map features may be limited');
                }
                
                const response = await fetch(DATA_URL, {
                    method: 'GET',
                    headers: {
                        'Accept': 'application/json',
                    }
                });
                
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                
                const data = await response.json();
                console.log('Data fetched successfully:', data);
                
                // Update the global data objects
                if (data.ELECTION_DATA) {
                    ELECTION_DATA = data.ELECTION_DATA;
                    console.log('ELECTION_DATA loaded:', ELECTION_DATA);
                }
                if (data.SEAT_RESULTS) {
                    SEAT_RESULTS = data.SEAT_RESULTS;
                    console.log('SEAT_RESULTS loaded:', SEAT_RESULTS);
                }
                
                // If data structure is different (direct state/lc keys)
                if (!data.ELECTION_DATA && (data.state || data.lc)) {
                    ELECTION_DATA.state = data.state || {};
                    ELECTION_DATA.lc = data.lc || {};
                    console.log('Alternative data structure detected and loaded');
                }
                
                // Initialize the dashboard with default selections
                updateYearDropdown();
                updateElectorateDropdown();
                updateBoothDropdown();
                updateCandidateDropdown();
                updateDashboard();
                
                // Hide loading message
                const loadingMsg = document.getElementById('loadingMessage');
                if (loadingMsg) {
                    loadingMsg.style.display = 'none';
                }
                
            } catch (error) {
                console.error('Error fetching data:', error);
                
                // Show error message with more details
                const content = document.getElementById('mainContent');
                content.innerHTML = `
                    <div class="panel full-width">
                        <h2>Error Loading Data</h2>
                        <p style="color: #d32f2f;">Failed to load election data from GitHub.</p>
                        <p>Error: ${error.message}</p>
                        <p style="margin-top: 1rem;">Please check:</p>
                        <ul style="margin-left: 2rem;">
                            <li>The GitHub repository is public</li>
                            <li>The JSON file exists at the specified URL</li>
                            <li>The JSON format is valid</li>
                            <li>Check browser console (F12) for more details</li>
                        </ul>
                        <p style="margin-top: 1rem;">URL attempted: <code style="background: #f5f5f5; padding: 0.25rem 0.5rem; border-radius: 4px;">${DATA_URL}</code></p>
                        <div style="margin-top: 2rem; display: flex; gap: 1rem;">
                            <button onclick="location.reload()">Retry Loading</button>
                            <button onclick="useFallbackData()" style="background: var(--federal-navy);">Use Demo Data</button>
                            <button onclick="showManualInput()" style="background: var(--federal-dark);">Paste JSON Manually</button>
                        </div>
                        <div id="manualInputArea" style="display: none; margin-top: 2rem;">
                            <h3>Paste JSON Data</h3>
                            <textarea id="jsonInput" style="width: 100%; height: 200px; font-family: monospace; padding: 0.5rem; border: 2px solid var(--federal-gold); border-radius: 6px;" placeholder="Paste your JSON data here..."></textarea>
                            <button onclick="loadManualData()" style="margin-top: 1rem;">Load Data</button>
                        </div>
                    </div>
                `;
                
                // Hide loading message
                const loadingMsg = document.getElementById('loadingMessage');
                if (loadingMsg) {
                    loadingMsg.style.display = 'none';
                }
            }
        }
        
        // =====================================================
        // CORE FUNCTIONS
        // =====================================================
        
        let currentElectionType = 'state';
        let currentData = [];
        let charts = {};
        let selectedParties = new Set(['ALL']);
        let boothMap = null;
        let mapMarkers = null;
        
        const NON_PHYSICAL_BOOTHS = [
            'postal', 'pre-poll', 'prepoll', 'mobile', 'provisional', 
            'out of division', 'telephone', 'pre poll', 'absent'
        ];
        
        function isPhysicalBooth(boothName) {
            const lowerName = boothName.toLowerCase();
            return !NON_PHYSICAL_BOOTHS.some(pattern => lowerName.includes(pattern));
        }
        
        
        // Normalize party codes and names to a single canonical set
        function normalizeParty(p) {
            const s = (p || '').toString().trim().toUpperCase();
            const map = {
                // Majors
                'LABOR': 'ALP', 'ALP': 'ALP',
                'LIBERAL': 'LIB', 'LIB': 'LIB',
                'GREENS': 'GRN', 'GRN': 'GRN',
                'INDEPENDENT': 'IND', 'IND': 'IND',
                // Minors / aliases
                'SFF': 'SFF', 'SSF': 'SFF', 'SHOOTERS & FISHERS': 'SFF',
                'NAT': 'NAT', 'NATIONALS': 'NAT',
                'JLN': 'JLN', 'JACQUI LAMBIE NETWORK': 'JLN',
                // Informal
                'INF': 'INF', 'INFORMAL': 'INF'
            };
            return map[s] || s;
        }
        
function getPartyColor(party) {
            const colorMap = {
                'LIB': '#8EAADB',
                'LIBERAL': '#8EAADB',
                'ALP': '#EB8989',
                'LABOR': '#EB8989',
                'GRN': '#A8D08D',
                'GREENS': '#A8D08D',
                'IND': '#7030A0',
                'INDEPENDENT': '#7030A0',
                'JLN': '#FFD966',
                'NAT': '#008000',
                'SFF': '#805200',
                'Shooters & Fishers': '#805200',
                'INF': '#666666'
            };
            return colorMap[normalizeParty(party)] || '#B8B8B8';
        }
        
        function getPartyName(code) {
            const partyNames = {
                'ALP': 'Labor',
                'LABOR': 'Labor',
                'LIB': 'Liberal',
                'LIBERAL': 'Liberal',
                'GRN': 'Greens',
                'GREENS': 'Greens',
                'IND': 'Independent',
                'INDEPENDENT': 'Independent',
                'JLN': 'JLN',
                'SFF': 'Shooters & Fishers',
                'Shooters & Fishers': 'Shooters & Fishers',
                'INF': 'Informal',
                'NAT': 'Nationals'
            };
            return partyNames[normalizeParty(code)] || code;
        }
        
        // Calculate booth winners from candidate data
        function calculateBoothWinners(year, electorate = '') {
            const data = currentElectionType === 'state' 
                ? ELECTION_DATA.state[year] 
                : ELECTION_DATA.lc[year];
            
            if (!data) return [];
            
            const boothResults = {};
            
            // Filter by electorate if specified
            const candidates = electorate 
                ? data.filter(d => d.d === electorate)
                : data;
            
            // Aggregate votes by booth
            candidates.forEach(candidate => {
                if (candidate.b && Array.isArray(candidate.b)) {
                    candidate.b.forEach(booth => {
                        if (isPhysicalBooth(booth.n)) {
                            if (!boothResults[booth.n]) {
                                boothResults[booth.n] = {
                                    name: booth.n,
                                    electorate: candidate.d,
                                    parties: {}
                                };
                            }
                            
                            const party = candidate.p;
                            if (!boothResults[booth.n].parties[party]) {
                                boothResults[booth.n].parties[party] = 0;
                            }
                            boothResults[booth.n].parties[party] += booth.v;
                        }
                    });
                }
            });
            
            // Determine winner for each booth
            const winners = [];
            Object.values(boothResults).forEach(booth => {
                let maxVotes = 0;
                let winningParty = '';
                
                Object.entries(booth.parties).forEach(([party, votes]) => {
                    if (votes > maxVotes && party !== 'INF') {
                        maxVotes = votes;
                        winningParty = party;
                    }
                });
                
                if (winningParty) {
                    winners.push({
                        name: booth.name,
                        electorate: booth.electorate,
                        party: winningParty,
                        votes: maxVotes,
                        margin: 0
                    });
                }
            });
            
            // Filter by selected parties
            return winners.filter(booth => {
                if (selectedParties.has('NONE')) return false;
                if (selectedParties.has('ALL')) return true;
                return selectedParties.has(booth.party);
            });
        }
        
        // Initialize
        document.addEventListener('DOMContentLoaded', function() {
            // Show loading message
            const content = document.getElementById('mainContent');
            content.innerHTML = `
                <div class="panel full-width" id="loadingMessage">
                    <h2>Loading Election Data...</h2>
                    <p style="text-align: center; padding: 2rem;">
                        <span style="font-size: 2rem;">⏳</span><br>
                        Fetching data from William's JSON Server<br>
                        <small style="opacity: 0.7;">This may take a few moments</small>
                    </p>
                    <div style="text-align: center; margin-top: 2rem;">
                        <button onclick="useFallbackData()" style="background: var(--federal-navy);">Use Demo Data Instead</button>
                    </div>
                </div>
            `;
            
            // Fetch data from GitHub
            fetchElectionData();
        });
        
        // Fallback function to use demo data
        function useFallbackData() {
            // Use minimal demo data
            ELECTION_DATA = {
                state: {
                    "2025": [
                        {"d": "Bass", "c": "Demo Candidate", "p": "ALP", "v": 1000, "b": [{"n": "Launceston", "v": 500}, {"n": "George Town", "v": 500}]}
                    ]
                },
                lc: {
                    "2024": [
                        {"d": "Elwick", "c": "Demo LC Candidate", "p": "IND", "v": 2000, "b": [{"n": "Glenorchy", "v": 1000}, {"n": "Moonah", "v": 1000}]}
                    ]
                }
            };
            
            SEAT_RESULTS = {
                state: {
                    "2025": [
                        {"electorate": "Bass", "party": "LABOR", "seats_won": 3, "total_seat_pct": "8.57%"},
                        {"electorate": "Bass", "party": "LIBERAL", "seats_won": 4, "total_seat_pct": "11.43%"}
                    ]
                },
                lc: {}
            };
            
            // Add demo polling places if not loaded
            if (Object.keys(POLLING_PLACES).length === 0) {
                POLLING_PLACES = {
                    "Launceston": {"lat": -41.43659, "lng": 147.13718, "electorate": "Bass"},
                    "George Town": {"lat": -41.10686, "lng": 146.82194, "electorate": "Bass"},
                    "Glenorchy": {"lat": -42.830908, "lng": 147.267619, "electorate": "Clark"},
                    "Moonah": {"lat": -42.84612742, "lng": 147.2997299, "electorate": "Clark"}
                };
            }
            
            console.log('Using fallback demo data');
            updateYearDropdown();
            updateDashboard();
            
            // Show notification
            const content = document.getElementById('mainContent');
            const notification = document.createElement('div');
            notification.style = 'background: #fff3cd; border: 1px solid #ffc107; padding: 1rem; margin-bottom: 1rem; border-radius: 8px;';
            notification.innerHTML = '<strong>Note:</strong> Using demo data. GitHub data could not be loaded.';
            content.insertBefore(notification, content.firstChild);
        }
        
        // Show manual input area
        function showManualInput() {
            const manualArea = document.getElementById('manualInputArea');
            if (manualArea) {
                manualArea.style.display = 'block';
            }
        }
        
        // Load manually pasted data
        function loadManualData() {
            try {
                const jsonInput = document.getElementById('jsonInput');
                if (!jsonInput || !jsonInput.value.trim()) {
                    alert('Please paste JSON data first');
                    return;
                }
                
                const data = JSON.parse(jsonInput.value);
                console.log('Manual data parsed:', data);
                
                // Update the global data objects
                if (data.ELECTION_DATA) {
                    ELECTION_DATA = data.ELECTION_DATA;
                } else if (data.state || data.lc) {
                    // Handle alternative structure
                    ELECTION_DATA.state = data.state || {};
                    ELECTION_DATA.lc = data.lc || {};
                }
                
                if (data.SEAT_RESULTS) {
                    SEAT_RESULTS = data.SEAT_RESULTS;
                } else if (data.seat_results) {
                    // Handle alternative naming
                    SEAT_RESULTS = data.seat_results;
                }
                
                console.log('Manual data loaded successfully');
                updateYearDropdown();
                updateDashboard();
                
            } catch (error) {
                alert('Error parsing JSON: ' + error.message);
                console.error('Manual data parse error:', error);
            }
        }
        
        function updateYearDropdown() {
            const yearSelect = document.getElementById('yearSelect');
            yearSelect.innerHTML = '';
            
            const years = currentElectionType === 'state' 
                ? Object.keys(ELECTION_DATA.state).filter(y => ELECTION_DATA.state[y].length > 0).sort((a, b) => b - a)
                : Object.keys(ELECTION_DATA.lc).filter(y => ELECTION_DATA.lc[y].length > 0).sort((a, b) => b - a);
            
            years.forEach(year => {
                yearSelect.innerHTML += `<option value="${year}">${year}</option>`;
            });
            
            yearSelect.value = years[0] || '';
        }
        
        function switchElectionType(type) {
            currentElectionType = type;
            document.getElementById('btnState').classList.toggle('active', type === 'state');
            document.getElementById('btnLC').classList.toggle('active', type === 'lc');
            updateYearDropdown();
            updateDashboard();
        }
        
        function updateDashboard() {
            const scope = document.getElementById('scopeSelect').value;
            const year = document.getElementById('yearSelect').value;
            const electorate = document.getElementById('electorateSelect').value;
            const booth = document.getElementById('boothSelect').value;
            const candidate = document.getElementById('candidateSelect').value;

            // Clear existing charts and map
            Object.values(charts).forEach(chart => {
                if (chart) chart.destroy();
            });
            charts = {};
            
            if (boothMap) {
                boothMap.remove();
                boothMap = null;
                mapMarkers = null;
            }
            
            // Show/hide controls
            const isHistorical = scope === 'historical';
            document.getElementById('yearGroup').style.display = isHistorical ? 'none' : 'block';
            document.getElementById('electorateGroup').style.display = 
                (scope === 'electorate' || scope === 'booth' || scope === 'candidate' || scope === 'boothAnalysis') ? 'block' : 'none';
            document.getElementById('boothGroup').style.display = 
                scope === 'booth' ? 'block' : 'none';
            document.getElementById('candidateGroup').style.display = 
                scope === 'candidate' ? 'block' : 'none';
            
            document.getElementById('electorateLabel').textContent = 
                scope === 'electorate' ? 'Select Electorate' : 'Filter by Electorate';
            
            // Render appropriate view
            const content = document.getElementById('mainContent');
            
            switch(scope) {
                case 'historical':
                    renderHistoricalView(content);
                    break;
                case 'state':
                    renderStatewideView(content, year);
                    break;
                case 'electorate':
                    renderElectorateView(content, year, electorate);
                    break;
                case 'booth':
                    renderBoothView(content, year, electorate, booth);
                    break;
                case 'candidate':
                    renderCandidateView(content, year, candidate);
                    break;
                case 'boothAnalysis':
                    renderBoothAnalysisView(content, year, electorate);
                    break;
            }
            
            updateElectorateDropdown();
            if (scope === 'booth') updateBoothDropdown();
            if (scope === 'candidate') updateCandidateDropdown();
        }
        
        function getCurrentData(year, scope, electorate, booth, candidate) {
            let data = [];
            
            const electionData = currentElectionType === 'state' 
                ? ELECTION_DATA.state 
                : ELECTION_DATA.lc;
            
            if (!year || year === '') return data;
            
            data = electionData[year] || [];
            
            if (electorate && scope !== 'state') {
                data = data.filter(d => d.d === electorate);
            }
            
            if (candidate && scope === 'candidate') {
                data = data.filter(d => d.c === candidate);
            }
            
            return data;
        }
        
        function updateElectorateDropdown() {
            const electorateSelect = document.getElementById('electorateSelect');
            const currentValue = electorateSelect.value;
            electorateSelect.innerHTML = '<option value="">All Electorates</option>';
            
            const year = document.getElementById('yearSelect').value;
            const data = currentElectionType === 'state' 
                ? ELECTION_DATA.state[year] 
                : ELECTION_DATA.lc[year];
            
            if (!data) return;
            
            const electorates = [...new Set(data.map(d => d.d))].sort();
            
            electorates.forEach(elec => {
                electorateSelect.innerHTML += `<option value="${elec}">${elec}</option>`;
            });
            
            if (currentValue && electorates.includes(currentValue)) {
                electorateSelect.value = currentValue;
            }
        }
        
        function updateBoothDropdown() {
            const boothSelect = document.getElementById('boothSelect');
            const currentValue = boothSelect.value;
            const year = document.getElementById('yearSelect').value;
            const electorate = document.getElementById('electorateSelect').value;

            boothSelect.innerHTML = '<option value="">All Booths</option>';

            const booths = [];

            if (currentElectionType === 'state') {
                // Use polling place data to gather booths for the selected state electorate
                Object.entries(POLLING_PLACES).forEach(([name, info]) => {
                    if (!electorate || info.electorate === electorate) {
                        if (isPhysicalBooth(name)) booths.push(name);
                    }
                });
            } else {
                // Legislative Council – build booth to electorate map from election data
                const data = (ELECTION_DATA.lc && ELECTION_DATA.lc[year]) || [];
                const lcBoothMap = new Map();
                data.forEach(row => {
                    if (Array.isArray(row.b)) {
                        row.b.forEach(b => lcBoothMap.set(keyForBooth(b.n), row.d));
                    }
                });

                Object.entries(POLLING_PLACES).forEach(([name, info]) => {
                    const key = keyForBooth(name);
                    const lcElectorate = lcBoothMap.get(key);
                    if (!lcElectorate) return; // booth not in LC data
                    if (!electorate || lcElectorate === electorate) {
                        if (isPhysicalBooth(name)) booths.push(name);
                    }
                });
            }

            booths.sort().forEach(booth => {
                boothSelect.innerHTML += `<option value="${booth}">${booth}</option>`;
            });

            if (currentValue && booths.includes(currentValue)) {
                boothSelect.value = currentValue;
            }
        }
        
        function updateCandidateDropdown() {
            const candidateSelect = document.getElementById('candidateSelect');
            const currentValue = candidateSelect.value;
            const year = document.getElementById('yearSelect').value;
            const electorate = document.getElementById('electorateSelect').value;
            
            candidateSelect.innerHTML = '<option value="">Select a candidate</option>';
            
            const data = getCurrentData(year, 'candidate', electorate, '', '');
            
            const candidates = [...new Set(data.map(d => d.c))].sort();
            
            candidates.forEach(cand => {
                const candidateData = data.find(d => d.c === cand);
                const party = candidateData ? candidateData.p : '';
                candidateSelect.innerHTML += `<option value="${cand}">${cand} (${party})</option>`;
            });
            
            if (currentValue && candidates.includes(currentValue)) {
                candidateSelect.value = currentValue;
            }
        }
        
        function renderStatewideView(container, year) {
            const seatData = currentElectionType === 'state' && SEAT_RESULTS.state[year] 
                ? SEAT_RESULTS.state[year] 
                : [];
            
            container.innerHTML = `
                <div class="panel-grid">
                    <div class="panel">
                        <h2>Party Performance</h2>
                        <div class="chart-container">
                            <canvas id="partyChart"></canvas>
                        </div>
                        <div class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Party</th>
                                        <th>Votes</th>
                                        <th>Percentage</th>
                                        <th>Seats Won</th>
                                    </tr>
                                </thead>
                                <tbody id="partyTableBody"></tbody>
                            </table>
                        </div>
                    </div>
                    
                    <div class="panel">
                        <h2>Seat Distribution</h2>
                        <div class="chart-container">
                            <canvas id="seatChart"></canvas>
                        </div>
                        <div class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Electorate</th>
                                        <th>Labor</th>
                                        <th>Liberal</th>
                                        <th>Greens</th>
                                        <th>Other</th>
                                    </tr>
                                </thead>
                                <tbody id="seatTableBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
                
                <div class="panel full-width">
                    <h2>Booth Winners Map</h2>
                    <div class="booth-filters">
                        <div class="control-group">
                            <label>Party Filter</label>
                            <div class="multi-select-container">
                                <div class="multi-select-display" onclick="togglePartyFilter()">
                                    <span id="partyFilterText">All Parties</span>
                                    <span>▼</span>
                                </div>
                                <div id="partyFilterDropdown" class="multi-select-dropdown">
                                    <div class="multi-select-option">
                                        <input type="checkbox" id="party-all" checked onchange="toggleAllParties(this)">
                                        <label for="party-all">All Parties</label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="boothMap"></div>
                    <div class="table-container" style="margin-top: 1rem;">
                        <table>
                            <thead>
                                <tr>
                                    <th>Booth</th>
                                    <th>Electorate</th>
                                    <th>Winning Party</th>
                                    <th>Votes</th>
                                </tr>
                            </thead>
                            <tbody id="boothTableBody"></tbody>
                        </table>
                    </div>
                </div>
            `;
            
            initializePartyFilter();
            loadStatewideData(year);
            
            setTimeout(() => {
                const boothWinners = calculateBoothWinners(year, '');
                if (boothWinners.length > 0) {
                    createBoothWinnersMap(boothWinners);
                    if (boothMap) {
                        boothMap.invalidateSize();
                    }
                }
            }, 200);
        }
        
        function renderElectorateView(container, year, electorate) {
            const electorateName = electorate || 'All Electorates';
            container.innerHTML = `
                <div class="panel-grid">
                    <div class="panel">
                        <h2>Party Performance - ${electorateName}</h2>
                        <div class="chart-container">
                            <canvas id="partyChart"></canvas>
                        </div>
                        <div class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Party</th>
                                        <th>Votes</th>
                                        <th>Percentage</th>
                                        <th>Candidates</th>
                                    </tr>
                                </thead>
                                <tbody id="partyTableBody"></tbody>
                            </table>
                        </div>
                    </div>
                    
                    <div class="panel">
                        <h2>Candidates - ${electorateName}</h2>
                        <div class="chart-container">
                            <canvas id="candidateChart"></canvas>
                        </div>
                        <div class="table-container">
                            <table>
                                <thead>
                                    <tr>
                                        <th>Candidate</th>
                                        <th>Party</th>
                                        <th>Votes</th>
                                        <th>Percentage</th>
                                    </tr>
                                </thead>
                                <tbody id="candidateTableBody"></tbody>
                            </table>
                        </div>
                    </div>
                </div>
                
                <div class="panel full-width">
                    <h2>Booth Winners - ${electorateName}</h2>
                    <div class="booth-filters">
                        <div class="control-group">
                            <label>Party Filter</label>
                            <div class="multi-select-container">
                                <div class="multi-select-display" onclick="togglePartyFilter()">
                                    <span id="partyFilterText">All Parties</span>
                                    <span>▼</span>
                                </div>
                                <div id="partyFilterDropdown" class="multi-select-dropdown">
                                    <div class="multi-select-option">
                                        <input type="checkbox" id="party-all" checked onchange="toggleAllParties(this)">
                                        <label for="party-all">All Parties</label>
                                    </div>
                                </div>
                            </div>
                        </div>
                    </div>
                    <div id="boothMap"></div>
                    <div class="table-container" style="margin-top: 1rem;">
                        <table>
                            <thead>
                                <tr>
                                    <th>Booth</th>
                                    <th>Winning Party</th>
                                    <th>Votes</th>
                                </tr>
                            </thead>
                            <tbody id="boothTableBody"></tbody>
                        </table>
                    </div>
                </div>
            `;
            
            initializePartyFilter();
            loadElectorateData(year, electorate);
            
            setTimeout(() => {
                const boothWinners = calculateBoothWinners(year, electorate);
                if (boothWinners.length > 0) {
                    createBoothWinnersMap(boothWinners);
                    if (boothMap) {
                        boothMap.invalidateSize();
                    }
                }
            }, 200);
        }
        
        function renderBoothView(container, year, electorate, booth) {
            const boothName = booth || 'All Booths';
            container.innerHTML = `
                <div class="panel full-width">
                    <h2>Booth Results - ${boothName}</h2>
                    <div class="panel-grid">
                        <div>
                            <h3>Vote Distribution</h3>
                            <div id="voteToggleGroup" style="margin: 0.25rem 0 0.5rem 0; display:flex; gap:0.5rem; flex-wrap:wrap;">
                                <button id="voteTopBtn" class="active" title="Show the top 15 candidates by votes">Top 15</button>
                                <button id="voteAllBtn" title="Show all candidates">All candidates</button>
                            </div>
                            <div class="chart-container">
                                <canvas id="voteChart"></canvas>
                            </div>
                            <h3 style="margin-top:1.5rem;">Detailed Results</h3>
                            <div class="table-container">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Candidate</th>
                                            <th>Party</th>
                                            <th>Votes</th>
                                            <th>Booth %</th>
                                            <th>Cand %</th>
                                        </tr>
                                    </thead>
                                    <tbody id="boothResultsBody"></tbody>
                                </table>
                            </div>
                        </div>
                        <div>
                            <h3>Booth Map</h3>
                            <div id="boothMap"></div>
                        </div>
                    </div>
                </div>
            `;

            loadBoothData(year, electorate, booth);
            createBoothSelectionMap(electorate, booth);
        }
        
        function renderCandidateView(container, year, candidate) {
            const candidateName = candidate || 'Select a candidate';
            container.innerHTML = `
                <div class="panel full-width">
                    <h2>Candidate Profile - ${candidateName}</h2>
                    <div class="panel-grid">
                        <div>
                            <h3>Performance by Location</h3>
                            <div class="chart-container">
                                <canvas id="candidateLocationChart"></canvas>
                            </div>
                        </div>
                        <div>
                            <h3>Booth-by-Booth Results</h3>
                            <div class="table-container">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Booth</th>
                                            <th>Electorate</th>
                                            <th>Votes</th>
                                        </tr>
                                    </thead>
                                    <tbody id="candidateBoothBody"></tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
            `;
            
            if (candidate) {
                loadCandidateData(year, candidate);
            }
        }
        
        
        // ==========================================
        // Booth Analysis (rank shifts between years)
        // ==========================================
        function getAvailableYears() {
            const bucket = (currentElectionType === 'state') ? ELECTION_DATA.state : ELECTION_DATA.lc;
            return Object.keys(bucket || {}).filter(y => (bucket[y] || []).length > 0).map(y => parseInt(y,10)).sort((a,b)=>a-b);
        }
        function getPreviousYear(currentYear) {
            const years = getAvailableYears();
            const y = parseInt(currentYear, 10);
            let prev = null;
            for (let i = years.length - 1; i >= 0; i--) {
                if (years[i] < y) { prev = years[i]; break; }
            }
            return prev;
        }
        function aggregateBoothPartyVotes(year, electorateFilter) {
            const data = (currentElectionType === 'state') ? ELECTION_DATA.state[year] : ELECTION_DATA.lc[year];
            if (!data) return {};
            const booths = {};
            const useElectorate = electorateFilter && electorateFilter !== '';
            (useElectorate ? data.filter(d => d.d === electorateFilter) : data).forEach(candidate => {
                if (candidate.b && Array.isArray(candidate.b)) {
                    candidate.b.forEach(booth => {
                        const boothName = booth.n;
                        if (!isPhysicalBooth(boothName)) return;
                        const key = (typeof keyForBooth === 'function') ? keyForBooth(boothName) : boothName;
                        if (!booths[key]) {
                            booths[key] = { name: boothName, electorate: candidate.d, parties: {} };
                        }
                        const party = normalizeParty(candidate.p);
                        if (party === 'INF') return; // exclude Informal from ranking
                        booths[key].parties[party] = (booths[key].parties[party] || 0) + (booth.v || 0);
                    });
                }
            });
            return booths;
        }
        function ranksFromPartyVotes(partyVotes) {
            // returns {party->rank} and rank order array
            const entries = Object.entries(partyVotes || {}).sort((a,b)=>b[1]-a[1]);
            const ranks = {};
            let rank = 1;
            entries.forEach(([p,_votes], idx) => {
                if (idx > 0 && entries[idx-1][1] !== _votes) rank = idx+1; // dense ranking
                ranks[p] = rank;
            });
            return { ranks, order: entries.map(e=>e[0]) };
        }
        function computeBoothRankShifts(currYear, prevYear, electorateFilter) {
            const curr = aggregateBoothPartyVotes(currYear, electorateFilter);
            const prev = prevYear ? aggregateBoothPartyVotes(prevYear, electorateFilter) : {};
            
            const partiesSet = new Set();
            const partyStats = {}; // per party aggregates
            const topChanges = []; // booths where #1 changed
            let boothsConsidered = 0;
            let boothsWithAnyChange = 0;
            
            // helper to init party stats
            function ensureParty(p){
                if (!partyStats[p]) partyStats[p] = { gainedFirst:0, lostFirst:0, netRankDelta:0 };
            }
            
            Object.keys(curr).forEach(key => {
                if (!prev[key]) return; // compare only if booth exists in both years
                const c = curr[key], p = prev[key];
                const cr = ranksFromPartyVotes(c.parties);
                const pr = ranksFromPartyVotes(p.parties);
                
                boothsConsidered++;
                let anyChange = false;
                
                // union of parties present across both
                const allParties = new Set([...Object.keys(c.parties||{}), ...Object.keys(p.parties||{})]);
                allParties.forEach(pt => {
                    ensureParty(pt);
                    const r0 = pr.ranks[pt];
                    const r1 = cr.ranks[pt];
                    if (r0 != null && r1 != null) {
                        const delta = (r0 - r1); // + means improved rank
                        partyStats[pt].netRankDelta += delta;
                        if (delta !== 0) anyChange = true;
                        if (r0 === 1 && r1 !== 1) partyStats[pt].lostFirst += 1;
                        if (r0 !== 1 && r1 === 1) partyStats[pt].gainedFirst += 1;
                    }
                });
                
                const prevTop = pr.order[0] || null;
                const currTop = cr.order[0] || null;
                if (prevTop && currTop && prevTop !== currTop) {
                    topChanges.push({
                        booth: c.name,
                        electorate: c.electorate,
                        prevTop,
                        currTop
                    });
                    anyChange = true;
                }
                if (anyChange) boothsWithAnyChange++;
            });
            
            // build party arrays
            const parties = Array.from(new Set([...Object.keys(partyStats)])).sort();
            const statsArray = parties.map(p => ({ party: p, ...partyStats[p] }));
            return {
                parties, partyStats, statsArray,
                topChanges,
                boothsConsidered, boothsWithAnyChange
            };
        }
        
        function renderBoothAnalysisView(container, year, electorate) {
            const prevYear = getPreviousYear(year);
            const scopeName = electorate && electorate !== '' ? electorate : 'Statewide';
            
            container.innerHTML = `
                <div class="panel full-width">
                    <h2>Booth Analysis — ${scopeName} <span title="Ranks are based on total primary votes per party at each physical booth (summing candidates per party). We compare the selected year to the previous election of the same type. Informal and non-physical booths are excluded.">ⓘ</span></h2>
                    <p style="margin-bottom: 0.75rem; color: #666;">Comparing <strong>${prevYear || '–'}</strong> → <strong>${year}</strong> (${currentElectionType.toUpperCase()})</p>
                    <div class="panel-grid">
                        <div class="panel">
                            <h3>First-Place Gains & Losses by Party</h3>
                            <div class="chart-container">
                                <canvas id="rankShiftChart"></canvas>
                            </div>
                        </div>
                        <div class="panel">
                            <h3>Summary</h3>
                            <div class="table-container">
                                <table>
                                    <thead>
                                        <tr>
                                            <th>Metric</th>
                                            <th>Value</th>
                                        </tr>
                                    </thead>
                                    <tbody id="boothAnalysisSummaryBody">
                                        <tr><td>Total booths compared</td><td>—</td></tr>
                                        <tr><td>Booths with any rank change</td><td>—</td></tr>
                                        <tr><td>Share with change</td><td>—</td></tr>
                                    </tbody>
                                </table>
                            </div>
                        </div>
                    </div>
                </div>
                <div class="panel full-width">
                    <h2>Booths where #1 party changed</h2>
                    <div class="table-container">
                        <table>
                            <thead>
                                <tr>
                                    <th>Booth</th>
                                    <th>Electorate</th>
                                    <th>#1 in ${prevYear || 'prev'}</th>
                                    <th>#1 in ${year}</th>
                                </tr>
                            </thead>
                            <tbody id="boothTopChangeBody">
                                <tr><td colspan="4">Loading...</td></tr>
                            </tbody>
                        </table>
                    </div>
                </div>
            `;
            
            loadBoothAnalysisData(year, prevYear, electorate);
        }
        
        function loadBoothAnalysisData(year, prevYear, electorate) {
            const res = computeBoothRankShifts(parseInt(year,10), prevYear ? parseInt(prevYear,10) : null, electorate);
            
            // Update summary table
            const summaryBody = document.getElementById('boothAnalysisSummaryBody');
            if (summaryBody) {
                const total = res.boothsConsidered;
                const changed = res.boothsWithAnyChange;
                const share = total > 0 ? ((changed/total)*100).toFixed(1) + '%' : '—';
                summaryBody.innerHTML = `
                    <tr><td>Total booths compared</td><td>${total}</td></tr>
                    <tr><td>Booths with any rank change</td><td>${changed}</td></tr>
                    <tr><td>Share with change</td><td>${share}</td></tr>
                `;
            }
            
            // Build chart datasets for gains/losses
            const parties = res.statsArray.map(s => s.party);
            const labels = parties.map(p => getPartyName(p));
            const gains = res.statsArray.map(s => s.gainedFirst);
            const losses = res.statsArray.map(s => s.lostFirst);
            
            const ctx = document.getElementById('rankShiftChart');
            if (ctx) {
                if (charts.rankShift) charts.rankShift.destroy();
                charts.rankShift = new Chart(ctx, {
                    type: 'bar',
                    data: {
                        labels,
                        datasets: [
                            {
                                label: 'Gains to 1st',
                                data: gains,
                                backgroundColor: parties.map(p => getPartyColor(p)),
                                borderWidth: 1
                            },
                            {
                                label: 'Losses from 1st',
                                data: losses,
                                backgroundColor: parties.map(p => getPartyColor(p)),
                                borderWidth: 1
                            }
                        ]
                    },
                    options: {
                    plugins: { legend: { display: false } },
                        responsive: true,
                        maintainAspectRatio: false,
                        scales: {
                            x: { stacked: false },
                            y: { beginAtZero: true, ticks: { precision: 0 } }
                        }
                    }
                });
            }
            
            // Top changes table
            const tbody = document.getElementById('boothTopChangeBody');
            if (tbody) {
                if (res.topChanges.length === 0) {
                    tbody.innerHTML = '<tr><td colspan="4">No booths changed #1 party for the selected comparison.</td></tr>';
                } else {
                    // Sort by party name then booth for stable display
                    const rows = res.topChanges
                        .slice()
                        .sort((a,b)=> (a.currTop.localeCompare(b.currTop) || a.booth.localeCompare(b.booth)))
                        .map(ch => `
                            <tr>
                                <td>${ch.booth}</td>
                                <td>${ch.electorate}</td>
                                <td><span style="display:inline-block;width:10px;height:10px;background:${getPartyColor(ch.prevTop)};margin-right:6px;border-radius:2px;"></span>${getPartyName(ch.prevTop)}</td>
                                <td><span style="display:inline-block;width:10px;height:10px;background:${getPartyColor(ch.currTop)};margin-right:6px;border-radius:2px;"></span>${getPartyName(ch.currTop)}</td>
                            </tr>
                        `).join('');
                    tbody.innerHTML = rows;
                }
            }
        }
function renderHistoricalView(container) {
            container.innerHTML = `
                <div class="panel full-width">
                    <h2>Historical Overview - ${currentElectionType === 'state' ? 'State Elections' : 'Legislative Council'}</h2>
                    <p style="margin-bottom: 1rem; color: #666;">
                        Comprehensive analysis of party performance, seat distribution, and electoral dynamics over time
                    </p>
                </div>
            `;
        }
        
        // Data loading functions
        function loadStatewideData(year) {
            const data = getCurrentData(year, 'state', '', '', '');
            
            // Process party performance
            const partyVotes = {};
            const partyCandidates = {};
            
            data.forEach(row => {
                const party = normalizeParty(row.p || 'IND');
                if (party !== 'INF') {
                    if (!partyVotes[party]) {
                        partyVotes[party] = 0;
                        partyCandidates[party] = 0;
                    }
                    partyVotes[party] += row.v;
                    partyCandidates[party]++;
                }
            });
            
            // Get seat data
            const seatData = currentElectionType === 'state' && SEAT_RESULTS.state[year] 
                ? SEAT_RESULTS.state[year] 
                : [];
            
            // Aggregate seats by party
            const partySeats = {};
            seatData.forEach(result => {
                const normalizedParty = normalizeParty(result.party);
                if (!partySeats[normalizedParty]) {
                    partySeats[normalizedParty] = 0;
                }
                partySeats[normalizedParty] += result.seats_won;
            });
            
            // Update party table
            const tbody = document.getElementById('partyTableBody');
            if (tbody) {
                tbody.innerHTML = '';
                const totalVotes = Object.values(partyVotes).reduce((a, b) => a + b, 0);
                
                Object.entries(partyVotes)
                    .sort((a, b) => b[1] - a[1])
                    .forEach(([party, votes]) => {
                        const row = tbody.insertRow();
                        const seats = partySeats[party] || 0;
                        row.innerHTML = `
                            <td><span class="party-badge" style="background: ${getPartyColor(party)}">${getPartyName(party)}</span></td>
                            <td>${votes.toLocaleString()}</td>
                            <td>${((votes / totalVotes) * 100).toFixed(1)}%</td>
                            <td>${seats}</td>
                        `;
                    });
            }
            
            // Update seat table
            const seatTableBody = document.getElementById('seatTableBody');
            if (seatTableBody && seatData.length > 0) {
                seatTableBody.innerHTML = '';
                const electorates = [...new Set(seatData.map(s => s.electorate))];
                
                electorates.forEach(elec => {
                    const row = seatTableBody.insertRow();
                    const elecSeats = seatData.filter(s => s.electorate === elec).map(s => ({...s, party: normalizeParty(s.party)}));
                    const labor = elecSeats.find(s => s.party === 'ALP')?.seats_won || 0;
                    const liberal = elecSeats.find(s => s.party === 'LIB')?.seats_won || 0;
                    const greens = elecSeats.find(s => s.party === 'GRN')?.seats_won || 0;
                    const other = elecSeats.filter(s => !['ALP','LIB','GRN'].includes(s.party))
                        .reduce((sum, s) => sum + s.seats_won, 0);
                    
                    row.innerHTML = `
                        <td>${elec}</td>
                        <td>${labor}</td>
                        <td>${liberal}</td>
                        <td>${greens}</td>
                        <td>${other}</td>
                    `;
                });
            }
            
            // Update booth winners table
            const boothBody = document.getElementById('boothTableBody');
            if (boothBody) {
                const boothWinners = calculateBoothWinners(year, '');
                boothBody.innerHTML = '';
                
                boothWinners.forEach(booth => {
                    const row = boothBody.insertRow();
                    row.innerHTML = `
                        <td>${booth.name}</td>
                        <td>${booth.electorate}</td>
                        <td><span class="party-badge" style="background: ${getPartyColor(booth.party)}">${getPartyName(booth.party)}</span></td>
                        <td>${booth.votes.toLocaleString()}</td>
                    `;
                });
            }
            
            // Create charts
            createPartyChart(partyVotes);
            createSeatChart(partySeats);
        }
        
        function loadElectorateData(year, electorate) {
            const data = getCurrentData(year, 'electorate', electorate, '', '');
            
            // Process party performance
            const partyVotes = {};
            
            data.forEach(row => {
                const party = normalizeParty(row.p || 'IND');
                if (party !== 'INF') {
                    if (!partyVotes[party]) {
                        partyVotes[party] = 0;
                    }
                    partyVotes[party] += row.v;
                }
            });
            
            // Update tables
            const partyBody = document.getElementById('partyTableBody');
            if (partyBody) {
                partyBody.innerHTML = '';
                const totalVotes = Object.values(partyVotes).reduce((a, b) => a + b, 0);
                
                Object.entries(partyVotes)
                    .sort((a, b) => b[1] - a[1])
                    .forEach(([party, votes]) => {
                        const row = partyBody.insertRow();
                        const candidates = data.filter(d => normalizeParty(d.p) === party).length;
                        row.innerHTML = `
                            <td><span class="party-badge" style="background: ${getPartyColor(party)}">${getPartyName(party)}</span></td>
                            <td>${votes.toLocaleString()}</td>
                            <td>${((votes / totalVotes) * 100).toFixed(1)}%</td>
                            <td>${candidates}</td>
                        `;
                    });
            }
            
            // Update candidate table
            const candidateBody = document.getElementById('candidateTableBody');
            if (candidateBody) {
                candidateBody.innerHTML = '';
                const sortedCandidates = [...data].sort((a, b) => b.v - a.v);
                const totalVotes = Object.values(partyVotes).reduce((a, b) => a + b, 0);
                
                sortedCandidates.forEach(cand => {
                    const row = candidateBody.insertRow();
                    row.innerHTML = `
                        <td>${cand.c}</td>
                        <td style="color: ${getPartyColor(cand.p)}">${getPartyName(cand.p)}</td>
                        <td>${cand.v.toLocaleString()}</td>
                        <td>${((cand.v / totalVotes) * 100).toFixed(2)}%</td>
                    `;
                });
            }
            
            // Update booth winners
            const boothBody = document.getElementById('boothTableBody');
            const boothWinners = calculateBoothWinners(year, electorate || '');
            
            if (boothBody) {
                boothBody.innerHTML = '';
                
                boothWinners.forEach(booth => {
                    const row = boothBody.insertRow();
                    row.innerHTML = `
                        <td>${booth.name}</td>
                        <td><span class="party-badge" style="background: ${getPartyColor(booth.party)}">${getPartyName(booth.party)}</span></td>
                        <td>${booth.votes.toLocaleString()}</td>
                    `;
                });
            }
            
            // Create charts
            createPartyChart(partyVotes);
            createCandidateChart(data);
        }
        
        function loadBoothData(year, electorate, booth) {
            const data = getCurrentData(year, 'booth', electorate, booth, '');
            const candidateTotals = {};

            // Pre-compute total votes per candidate across the current scope
            data.forEach(candidate => {
                let total = 0;
                if (candidate.b && Array.isArray(candidate.b)) {
                    candidate.b.forEach(b => {
                        if (isPhysicalBooth(b.n)) total += b.v;
                    });
                }
                candidateTotals[candidate.c] = total;
            });

            if (!booth || booth === '') {
                // Aggregate across all (physical) booths within the selected electorate (or statewide if none)
                const boothResults = [];
                data.forEach(candidate => {
                    const total = candidateTotals[candidate.c] || 0;
                    boothResults.push({
                        candidate: candidate.c,
                        party: candidate.p,
                        votes: total
                    });
                });

                // Populate results table
                const tbody = document.getElementById('boothResultsBody');
                if (tbody) {
                    tbody.innerHTML = '';
                    const totalVotes = boothResults.reduce((sum, r) => sum + r.votes, 0);
                    boothResults
                        .slice()
                        .sort((a, b) => b.votes - a.votes)
                        .forEach(result => {
                            const row = tbody.insertRow();
                            row.innerHTML = `
                                <td>${result.candidate}</td>
                                <td style="color: ${getPartyColor(result.party)}">${getPartyName(result.party)}</td>
                                <td>${result.votes.toLocaleString()}</td>
                                <td>${totalVotes ? ((result.votes / totalVotes) * 100).toFixed(1) : '0.0'}%</td>
                                <td>${candidateTotals[result.candidate] ? ((result.votes / candidateTotals[result.candidate]) * 100).toFixed(1) : '0.0'}%</td>
                            `;
                        });
                }

                // Draw chart with Top 15 default + toggle
                const sortedAll = boothResults.slice().sort((a, b) => b.votes - a.votes);
                const TOP_N = 15;
                createBoothVoteChart(sortedAll.slice(0, TOP_N));
                const topBtn = document.getElementById('voteTopBtn');
                const allBtn = document.getElementById('voteAllBtn');
                if (topBtn && allBtn) {
                    topBtn.classList.add('active');
                    allBtn.classList.remove('active');
                    topBtn.onclick = () => {
                        topBtn.classList.add('active');
                        allBtn.classList.remove('active');
                        createBoothVoteChart(sortedAll.slice(0, TOP_N));
                    };
                    allBtn.onclick = () => {
                        allBtn.classList.add('active');
                        topBtn.classList.remove('active');
                        createBoothVoteChart(sortedAll);
                    };
                }
                return;
            }

            
            // Get results for specific booth
            const boothResults = [];
            data.forEach(candidate => {
                if (candidate.b && Array.isArray(candidate.b)) {
                    const boothData = candidate.b.find(b => b.n === booth);
                    if (boothData) {
                        boothResults.push({
                            candidate: candidate.c,
                            party: candidate.p,
                            votes: boothData.v
                        });
                    }
                }
            });
            
            // Sort by votes
            boothResults.sort((a, b) => b.votes - a.votes);
            
            // Update table
            const tbody = document.getElementById('boothResultsBody');
            if (tbody) {
                tbody.innerHTML = '';
                const totalVotes = boothResults.reduce((sum, r) => sum + r.votes, 0);
                
                boothResults.forEach(result => {
                    const row = tbody.insertRow();
                    row.innerHTML = `
                        <td>${result.candidate}</td>
                        <td style="color: ${getPartyColor(result.party)}">${getPartyName(result.party)}</td>
                        <td>${result.votes.toLocaleString()}</td>
                        <td>${((result.votes / totalVotes) * 100).toFixed(1)}%</td>
                        <td>${candidateTotals[result.candidate] ? ((result.votes / candidateTotals[result.candidate]) * 100).toFixed(1) : '0.0'}%</td>
                    `;
                });
            }
            
            // Create vote distribution chart
            boothResults.sort((a, b) => b.votes - a.votes);
            const TOP_N = 15;
            createBoothVoteChart(boothResults.slice(0, TOP_N));
            const topBtn = document.getElementById('voteTopBtn');
            const allBtn = document.getElementById('voteAllBtn');
            if (topBtn && allBtn) {
                topBtn.onclick = () => {
                    topBtn.classList.add('active');
                    allBtn.classList.remove('active');
                    createBoothVoteChart(boothResults.slice(0, TOP_N));
                };
                allBtn.onclick = () => {
                    allBtn.classList.add('active');
                    topBtn.classList.remove('active');
                    createBoothVoteChart(boothResults);
                };
            }}
        
        function loadCandidateData(year, candidate) {
            const data = getCurrentData(year, 'candidate', '', '', candidate);
            
            if (!candidate || data.length === 0) {
                document.getElementById('candidateBoothBody').innerHTML = 
                    '<tr><td colspan="3">No data available for selected candidate</td></tr>';
                return;
            }
            
            const candidateData = data[0];
            const boothResults = candidateData.b || [];
            
            // Sort booths by votes
            boothResults.sort((a, b) => b.v - a.v);
            
            // Update table
            const tbody = document.getElementById('candidateBoothBody');
            if (tbody) {
                tbody.innerHTML = '';
                
                boothResults.forEach(booth => {
                    if (isPhysicalBooth(booth.n)) {
                        const row = tbody.insertRow();
                        row.innerHTML = `
                            <td>${booth.n}</td>
                            <td>${candidateData.d}</td>
                            <td>${booth.v.toLocaleString()}</td>
                        `;
                    }
                });
            }
            
            // Create location chart
            createCandidateLocationChart(boothResults.filter(b => isPhysicalBooth(b.n)));
        }
        
        // Chart creation functions
        function createPartyChart(partyVotes) {
            const ctx = document.getElementById('partyChart');
            if (!ctx) return;
            
            const totalVotes = Object.values(partyVotes).reduce((a, b) => a + b, 0);
            const sortedParties = Object.entries(partyVotes)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 10);

            if (charts.party) charts.party.destroy();

            charts.party = new Chart(ctx.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: sortedParties.map(p => getPartyName(p[0])),
                    datasets: [{
                        label: 'Vote %',
                        data: sortedParties.map(p => totalVotes ? (p[1] / totalVotes * 100) : 0),
                        backgroundColor: sortedParties.map(p => getPartyColor(p[0]))
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        y: {
                            beginAtZero: true,
                            max: 100,
                            ticks: {
                                callback: value => value + '%'
                            }
                        }
                    }
                }
            });
        }
        
        function createSeatChart(partySeats) {
            const ctx = document.getElementById('seatChart');
            if (!ctx) return;
            
            const parties = Object.keys(partySeats);
            const seats = Object.values(partySeats);
            
            if (charts.seats) charts.seats.destroy();
            
            charts.seats = new Chart(ctx.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: parties.map(p => getPartyName(p)),
                    datasets: [{
                        data: seats,
                        backgroundColor: parties.map(p => getPartyColor(p))
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false, position: 'right' }
                    }
                }
            });
        }
        
        function createCandidateChart(candidates) {
            const ctx = document.getElementById('candidateChart');
            if (!ctx) return;
            
            const sorted = [...candidates].sort((a, b) => b.v - a.v).slice(0, 15);
            
            if (charts.candidate) charts.candidate.destroy();
            
            charts.candidate = new Chart(ctx.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: sorted.map(c => c.c),
                    datasets: [{
                        label: 'Votes',
                        data: sorted.map(c => c.v),
                        backgroundColor: sorted.map(c => getPartyColor(c.p))
                    }]
                },
                options: {
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    }
                }
            });
        }
        
        function createBoothVoteChart(boothResults) {
            const ctx = document.getElementById('voteChart');
            if (!ctx) return;
            
            if (charts.vote) charts.vote.destroy();
            
            charts.vote = new Chart(ctx.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: boothResults.map(r => `${r.candidate} (${getPartyName(r.party)})`),
                    datasets: [{
                        data: boothResults.map(r => r.votes),
                        backgroundColor: boothResults.map(r => getPartyColor(r.party))
                    }]
                },
                options: {
                    plugins: { legend: { display: false } },
                    indexAxis: 'y',
                    responsive: true,
                    maintainAspectRatio: false
                }
            });
        }
        
        function createCandidateLocationChart(boothResults) {
            const ctx = document.getElementById('candidateLocationChart');
            if (!ctx) return;
            
            const top20 = boothResults.slice(0, 20);
            
            if (charts.candidateLocation) charts.candidateLocation.destroy();
            
            charts.candidateLocation = new Chart(ctx.getContext('2d'), {
                type: 'bar',
                data: {
                    labels: top20.map(b => b.n),
                    datasets: [{
                        label: 'Votes',
                        data: top20.map(b => b.v),
                        backgroundColor: '#4A5A6A'
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    plugins: {
                        legend: { display: false }
                    },
                    scales: {
                        x: {
                            ticks: {
                                maxRotation: 45,
                                minRotation: 45
                            }
                        }
                    }
                }
            });
        }

        function setupGeoJsonOverlayToggle(map) {
            if (!map || map.__overlayCtlAdded) return;
            map.__overlayCtlAdded = true;

            const OVERLAY_URLS = {
                state: 'https://raw.githubusercontent.com/williammanning68/Test-Fetch/main/State Election Electorate Boundaries.geojson',
                legco: 'https://raw.githubusercontent.com/williammanning68/Test-Fetch/main/Legislative Council Electorate Boundaries.geojson',
            };

            const state = { current: null, cache: {} };

            async function buildLayer(key) {
                if (state.cache[key]) return state.cache[key];
                const resp = await fetch(OVERLAY_URLS[key]);
                if (!resp.ok) throw new Error('Overlay fetch failed: ' + resp.status);
                const data = await resp.json();
                const layer = L.geoJSON(data, { style: { color: '#000', weight: 1.5, fillOpacity: 0 } });
                state.cache[key] = layer;
                return layer;
            }

            const OverlayCtl = L.Control.extend({
                options: { position: 'topright' },
                onAdd: function(map) {
                    const div = L.DomUtil.create('div', 'leaflet-bar overlay-select-control');
                    div.style.background = '#fff';
                    div.style.padding = '6px';
                    div.style.borderRadius = '8px';
                    div.style.boxShadow  = '0 1px 3px rgba(0,0,0,.2)';
                    const label = L.DomUtil.create('label', '', div);
                    label.textContent = 'Map overlay';
                    label.style.display = 'block';
                    label.style.fontSize = '12px';
                    label.style.marginBottom = '4px';
                    const sel = L.DomUtil.create('select', '', div);
                    sel.setAttribute('aria-label', 'Select map overlay');
                    sel.innerHTML = `
                        <option value="none">None</option>
                        <option value="state">State Electorates</option>
                        <option value="legco">Legislative Council</option>`;
                    L.DomEvent.disableClickPropagation(div);
                    sel.addEventListener('change', async (e) => {
                        const v = e.target.value;
                        if (state.current) { try { map.removeLayer(state.current); } catch(e){} state.current = null; }
                        if (v === 'none') return;
                        try {
                            const layer = await buildLayer(v);
                            state.current = layer;
                            map.addLayer(layer);
                        } catch (e) {
                            console.error(e);
                            alert('Could not load overlay "' + v + '". Check the GeoJSON URL and CORS.');
                        }
                    });
                    return div;
                }
            });
            map.addControl(new OverlayCtl());
        }

        function createBoothSelectionMap(electorate, selectedBooth = '') {
            if (boothMap) {
                boothMap.remove();
            }
            boothMap = L.map('boothMap').setView([-42.0, 147.0], 7);

            L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                attribution: '© OpenStreetMap contributors'
            }).addTo(boothMap);

            mapMarkers = L.layerGroup().addTo(boothMap);

            const year = document.getElementById('yearSelect').value;

            // Booth winners keyed by normalized booth name
            const winners = calculateBoothWinners(year, electorate || '');
            const winnerMap = new Map();
            winners.forEach(w => winnerMap.set(keyForBooth(w.name), w));

            // For LC elections, build a map of booth names to their LC electorates
            let lcBoothMap = null;
            if (currentElectionType === 'lc') {
                lcBoothMap = new Map();
                const data = (ELECTION_DATA.lc && ELECTION_DATA.lc[year]) || [];
                data.forEach(row => {
                    if (Array.isArray(row.b)) {
                        row.b.forEach(b => {
                            const key = keyForBooth(b.n);
                            if (!lcBoothMap.has(key)) {
                                lcBoothMap.set(key, row.d);
                            }
                        });
                    }
                });
            }

            Object.entries(POLLING_PLACES).forEach(([name, info]) => {
                const key = keyForBooth(name);

                if (currentElectionType === 'state') {
                    if (electorate && info.electorate !== electorate) return;
                } else {
                    const lcElect = lcBoothMap.get(key);
                    if (!lcElect) return;
                    if (electorate && lcElect !== electorate) return;
                }

                const winner = winnerMap.get(key);
                const color = winner ? getPartyColor(winner.party) : '#B8B8B8';

                const marker = L.circleMarker([info.lat, info.lng], {
                    radius: 6,
                    color: '#fff',
                    weight: 2,
                    fillColor: color,
                    fillOpacity: 1
                }).addTo(mapMarkers);

                const popupElectorate = currentElectionType === 'state'
                    ? info.electorate
                    : (lcBoothMap.get(key) || electorate);

                let popupContent = `<div class="booth-popup"><h3>${name}</h3><p><strong>Electorate:</strong> ${popupElectorate}</p>`;
                if (winner) {
                    popupContent += `<p><strong>Winner:</strong> <span class="winner" style="background:${color}">${getPartyName(winner.party)}</span></p>`;
                }
                popupContent += '</div>';

                marker.bindPopup(popupContent);
                marker.on('click', () => {
                    const boothSelect = document.getElementById('boothSelect');
                    const options = Array.from(boothSelect.options);
                    const match = options.find(opt => keyForBooth(opt.value) === key);
                    if (match) {
                        boothSelect.value = match.value;
                        updateDashboard();
                    }
                });

                if (selectedBooth && keyForBooth(selectedBooth) === key) {
                    marker.openPopup();
                    boothMap.setView([info.lat, info.lng], 12);
                }
            });

            if (mapMarkers.getLayers().length > 0) {
                boothMap.fitBounds(mapMarkers.getBounds(), { padding: [50, 50] });
            }

            setupGeoJsonOverlayToggle(boothMap);

            const legend = L.control({position: 'bottomright'});
            legend.onAdd = function(map) {
                const div = L.DomUtil.create('div', 'map-legend');
                div.innerHTML = `
                    <h4>Party Colors</h4>
                    <div class="legend-item">
                        <div class="legend-color" style="background: ${getPartyColor('ALP')}"></div>
                        <span>Labor</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: ${getPartyColor('LIB')}"></div>
                        <span>Liberal</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: ${getPartyColor('GRN')}"></div>
                        <span>Greens</span>
                    </div>
                    <div class="legend-item">
                        <div class="legend-color" style="background: ${getPartyColor('IND')}"></div>
                        <span>Independent</span>
                    </div>
                `;
                return div;
            };
            legend.addTo(boothMap);
        }

        // Map functions
        function createBoothWinnersMap(boothWinners) {
            if (!boothMap) {
                boothMap = L.map('boothMap').setView([-42.0, 147.0], 7);
                
                L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
                    attribution: '© OpenStreetMap contributors'
                }).addTo(boothMap);
                
                mapMarkers = L.markerClusterGroup({
                    chunkedLoading: true,
                    spiderfyOnMaxZoom: true,
                    showCoverageOnHover: false,
                    zoomToBoundsOnClick: true
                });
                
                
                // --- Dynamic clustering behaviour ---
                function _partyFilterSelected() {
                    const dd = document.getElementById('partyFilterDropdown');
                    if (!dd) return [];
                    return Array.from(dd.querySelectorAll('input[type=checkbox]:checked')).map(cb => cb.value);
                }
                function _clusterColorForSelected() {
                    const sel = _partyFilterSelected();
                    if (sel.length === 1) {
                        try { return getPartyColor(sel[0]); } catch(e) { return '#B8B8B8'; }
                    }
                    return '#B8B8B8';
                }
                if (typeof mapMarkers !== 'undefined' && mapMarkers) {
                    mapMarkers.options.iconCreateFunction = function(cluster) {
                        const count = cluster.getChildCount();
                        const color = _clusterColorForSelected();
                        const html = `<div style="
                            background:${color};
                            color:#000;
                            width:36px;height:36px;
                            line-height:36px;
                            border-radius:50%;
                            text-align:center;
                            font-weight:700;
                            box-shadow:0 0 0 2px #fff inset;
                        ">${count}</div>`;
                        return L.divIcon({ html, className: 'party-cluster', iconSize: [36,36] });
                    };
                    // Only cluster when exactly one party is selected
                    mapMarkers.options.maxClusterRadius = function(zoom) {
                        return _partyFilterSelected().length === 1 ? 80 : 0;
                    };
                    // Recompute when filter changes
                    (function wireClusterRefresh(){
                        const dd = document.getElementById('partyFilterDropdown');
                        if (!dd) return;
                        dd.querySelectorAll('input[type=checkbox]').forEach(cb => {
                            cb.addEventListener('change', function(){
                                if (mapMarkers && mapMarkers.refreshClusters) {
                                    mapMarkers.refreshClusters();
                                } else if (mapMarkers) {
                                    const m = window.boothMap || window.map;
                                    if (m) { m.removeLayer(mapMarkers); m.addLayer(mapMarkers); }
                                }
                            });
                        });
                    })();
                }
                boothMap.addLayer(mapMarkers);

                setupGeoJsonOverlayToggle(boothMap);

                const legend = L.control({position: 'bottomright'});
                legend.onAdd = function(map) {
                    const div = L.DomUtil.create('div', 'map-legend');
                    div.innerHTML = `
                        <h4>Party Colors</h4>
                        <div class="legend-item">
                            <div class="legend-color" style="background: ${getPartyColor('ALP')}"></div>
                            <span>Labor</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: ${getPartyColor('LIB')}"></div>
                            <span>Liberal</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: ${getPartyColor('GRN')}"></div>
                            <span>Greens</span>
                        </div>
                        <div class="legend-item">
                            <div class="legend-color" style="background: ${getPartyColor('IND')}"></div>
                            <span>Independent</span>
                        </div>
                    `;
                    return div;
                };
                legend.addTo(boothMap);
            }
            
            mapMarkers.clearLayers();
            
            boothWinners.forEach(booth => {
                const coords = (POLLING_PLACES[booth.name] || POLLING_PLACES[keyForBooth(booth.name)]);
                
                if (coords && coords.lat && coords.lng) {
                    const markerColor = getPartyColor(booth.party);
                    
                    const icon = L.divIcon({
                        className: 'custom-div-icon',
                        html: `<div style="background-color:${markerColor}; width: 20px; height: 20px; border-radius: 50%; border: 2px solid white; box-shadow: 0 1px 3px rgba(0,0,0,0.3);"></div>`,
                        iconSize: [20, 20],
                        iconAnchor: [10, 10]
                    });
                    
                    const marker = L.marker([coords.lat, coords.lng], {icon: icon});
                    
                    const popupContent = `
                        <div class="booth-popup">
                            <h3>${booth.name}</h3>
                            <p><strong>Electorate:</strong> ${booth.electorate}</p>
                            <p><strong>Winner:</strong> <span class="winner" style="background: ${markerColor}">${getPartyName(booth.party)}</span></p>
                            <p><strong>Votes:</strong> ${booth.votes.toLocaleString()}</p>
                        </div>
                    `;
                    
                    marker.bindPopup(popupContent);
                    mapMarkers.addLayer(marker);
                } else {
                    // Log missing coordinates for debugging, but don't break the map
                    console.warn(`No coordinates found for booth: ${booth.name}`);
                }
            });
            
            if (boothWinners.length > 0) {
                setTimeout(() => {
                    boothMap.fitBounds(mapMarkers.getBounds(), {padding: [50, 50]});
                }, 100);
            }
        }
        
        // Party filter functions
        function initializePartyFilter() {
            const dropdown = document.getElementById('partyFilterDropdown');
            if (!dropdown) return;
            
            while (dropdown.children.length > 1) {
                dropdown.removeChild(dropdown.lastChild);
            }
            
            const parties = ['ALP', 'LIB', 'GRN', 'IND', 'JLN', 'NAT', 'SFF'];
            
            parties.forEach(party => {
                const option = document.createElement('div');
                option.className = 'multi-select-option';
                option.innerHTML = `
                    <input type="checkbox" id="party-${party}" value="${party}" checked onchange="updatePartyFilter()">
                    <label for="party-${party}" style="color: ${getPartyColor(party)}">${getPartyName(party)}</label>
                `;
                dropdown.appendChild(option);
            });
        }
        
        function togglePartyFilter() {
            const dropdown = document.getElementById('partyFilterDropdown');
            if (dropdown) dropdown.classList.toggle('show');
        }
        
        function toggleAllParties(checkbox) {
            const checkboxes = document.querySelectorAll('#partyFilterDropdown input[type="checkbox"]:not(#party-all)');
            checkboxes.forEach(cb => cb.checked = checkbox.checked);
            updatePartyFilter();
        }
        
        function updatePartyFilter() {
            selectedParties.clear();
            const checkboxes = document.querySelectorAll('#partyFilterDropdown input[type="checkbox"]:checked:not(#party-all)');
            
            if (checkboxes.length === 0) {
                selectedParties.add('NONE');
                document.getElementById('partyFilterText').textContent = 'No parties selected';
            } else if (checkboxes.length === document.querySelectorAll('#partyFilterDropdown input[type="checkbox"]:not(#party-all)').length) {
                selectedParties.add('ALL');
                document.getElementById('partyFilterText').textContent = 'All Parties';
                document.getElementById('party-all').checked = true;
            } else {
                checkboxes.forEach(cb => selectedParties.add(cb.value));
                document.getElementById('partyFilterText').textContent = `${checkboxes.length} parties selected`;
                document.getElementById('party-all').checked = false;
            }
            
            const scope = document.getElementById('scopeSelect').value;
            if (scope === 'state' || scope === 'electorate') {
                const year = document.getElementById('yearSelect').value;
                const electorate = document.getElementById('electorateSelect').value;
                const boothWinners = calculateBoothWinners(year, electorate);
                if (boothWinners.length > 0 && boothMap) {
                    createBoothWinnersMap(boothWinners);
                }
            }
        }
        
        document.addEventListener('click', function(event) {
            if (!event.target.closest('.multi-select-container')) {
                const dropdown = document.getElementById('partyFilterDropdown');
                if (dropdown) dropdown.classList.remove('show');
            }
        });
    </script>
</body>
</html>